"""
This module implements linting and context-sensitive completions. The parser is based on
luaparse (https://github.com/oxyc/luaparse), which is a Lua parser implemented in Javascript, but modified
to implement certain additional checks and custom exceptions that are used to implement context-sensitive
completions. luaparse's license is included in the 'luaparse-LICENSE' file.
"""
import sublime, sublime_plugin, os, sys, json, re, copy, time, threading, cgi
from collections import namedtuple
ScopeCache = namedtuple('ScopeCache', ["scope", "starts", "ends"])
PYTHON_VERSION = sys.version_info
if PYTHON_VERSION[0] == 2:
	import imp
	scraper_module = os.path.join(os.getcwd(), "Scraper.py")
	imp.load_source("Scraper", scraper_module)
	del scraper_module
	shared_enums_module = os.path.join(os.getcwd(), "SharedEnums.py")
	imp.load_source("SharedEnums", shared_enums_module)
	del shared_enums_module
	shared_functions_module = os.path.join(os.getcwd(), "SharedFunctions.py")
	imp.load_source("SharedFunctions", shared_functions_module)
	del shared_functions_module
	lua_standard_libraries_module = os.path.join(os.getcwd(), "LuaStandardLibraries.py")
	imp.load_source("LuaStandardLibraries", lua_standard_libraries_module)
	del lua_standard_libraries_module
	import Scraper
	from SharedEnums import APIKeyEnum
	from SharedEnums import CompletionKeyEnum
	import SharedFunctions
	import LuaStandardLibraries
elif PYTHON_VERSION[0] >= 3:
	from . import Scraper
	from .SharedEnums import CompletionKeyEnum
	from .SharedEnums import APIKeyEnum
	from . import SharedFunctions
	from . import LuaStandardLibraries

# This is left here in case it is ever necessary to look at the execution time of specific functions.
#from functools import wraps
#def timed(f):
#	@wraps(f)
#	def wrapper(*args, **kwds):
#		start = time.time()
#		result = f(*args, **kwds)
#		elapsed = time.time() - start
#		print("%s took %f time to finish" % (f.__name__, elapsed*1000))
#		return result
#	return wrapper

class PreprocessorCommandEnum(object):
	"""
	Enum for special commands implemented as:

		--@COMMAND{;COMMAND}

	Currently the only supported command is for type annotations:

		Variable and parameter type annotation ::= [variable_type{, variable_type}]

		Function return type annotation ::= [-> function_return_type]

		Combined type annotations ::= variable_type{, variable_type} -> function_return_type

	{} = 0 or more times
	[] = optional
	"""
	RETURN_TYPES = "RETURN_TYPES" # Used to specify the type returned by a function
	VARIABLE_TYPES = "VARIABLE_TYPES" # Used to specify the types of variables in any variable declaration

class TokenEnum(object):
	"""
	Enum for tokens generated by the lexer.
	"""
	COLON = 0
	COMMA = 1
	DOT = 2
	DOUBLE_COLON = 3
	KW_AND = 4
	KW_BREAK = 5
	KW_DO = 6
	KW_ELSE = 7
	KW_ELSEIF = 8
	KW_END = 9
	KW_FALSE = 10
	KW_FOR = 11
	KW_FUNCTION = 12
	KW_GOTO = 13
	KW_IF = 14
	KW_IN = 15
	KW_LOCAL = 16
	KW_NIL = 17
	KW_NOT = 18
	KW_OR = 19
	KW_REPEAT = 20
	KW_RETURN = 21
	KW_THEN = 22
	KW_TRUE = 23
	KW_UNTIL = 24
	KW_WHILE = 25
	LEFT_BRACKET = 26
	LEFT_CURLY_BRACE = 27
	LEFT_PARENTHESIS = 28
	NAME = 29
	NUMBER = 30
	OP_ADD = 31
	OP_ASSIGN = 32
	OP_BIT_AND = 33
	OP_BIT_LSHIFT = 34
	OP_BIT_NOT_XOR = 35
	OP_BIT_OR = 36
	OP_BIT_RSHIFT = 37
	OP_CONCAT = 38
	OP_DIV = 39
	OP_EQUAL = 40
	OP_GREATER = 41
	OP_GREATER_THAN_OR_EQUAL = 42
	OP_IDIV = 43
	OP_LEN = 44
	OP_LESS = 45
	OP_LESS_THAN_OR_EQUAL = 46
	OP_MOD = 47
	OP_MUL = 48
	OP_NOT_EQUAL = 49
	OP_POW = 50
	OP_SUB = 51
	RIGHT_BRACKET = 52
	RIGHT_CURLY_BRACE = 53
	RIGHT_PARENTHESIS = 54
	SEMICOLON = 55
	STRING = 56
	VARARG = 57
	NEWLINE = 58
	UNMATCHED = 59
	EOF = 60
	LINE_COMMENT = 61
	BLOCK_COMMENT = 62
	WHITESPACE = 63
	PREPROCESSOR_COMMAND = 64

# User-friendly description of token. Values are used in error messages.
TOKEN_DESCRIPTION = [
	"colon",
	"comma",
	"dot",
	"double colon",
	"keyword 'and'",
	"keyword 'break'",
	"keyword 'do'",
	"keyword 'else'",
	"keyword 'elseif'",
	"keyword 'end'",
	"keyword 'false'",
	"keyword 'for'",
	"keyword 'function'",
	"keyword 'goto'",
	"keyword 'if'",
	"keyword 'in'",
	"keyword 'local'",
	"keyword 'nil'",
	"keyword 'not'",
	"keyword 'or'",
	"keyword 'repeat'",
	"keyword 'return'",
	"keyword 'then'",
	"keyword 'true'",
	"keyword 'until'",
	"keyword 'while'",
	"left bracket",
	"left curly brace",
	"left parenthesis",
	"name",
	"number literal",
	"addition operator",
	"assignment operator",
	"bitwise and operator",
	"bitwise left shift operator",
	"bitwise unary not/binary xor operator",
	"bitwise or operator",
	"bitwise right shift operator",
	"concatenation operator",
	"division operator",
	"equals comparison operator",
	"greater than comparison operator",
	"greater than or equal comparison operator",
	"floor division operator",
	"length operator",
	"less than comparison operator",
	"less than or equals comparison operator",
	"modulus operator",
	"multiplication operator",
	"not equals comparison operator",
	"power operator",
	"subtraction operator",
	"right bracket",
	"right curly brace",
	"right parenthesis",
	"semicolon",
	"string literal",
	"vararg operator",
	"newline",
	"unmatched",
	"end of file",
	"short comment",
	"long comment",
	"whitespace",
	"preprocessor command"
]

class Token(object):
	"""
	Object generated by the lexer.
	"""
	__slots__ = [
		"type", # TokenEnum
		"line", # str
		"column", # int
		"value" # int
	]
	def __init__(self, aType, aValue, aLine, aColumn):
		self.type = aType
		self.line = aLine
		self.column = aColumn
		self.value = aValue

	def __str__(self):
		return """
===== Token =====
Type: %s
Value: '%s'
Line: %d
Column: %d
""" % (TOKEN_DESCRIPTION[self.type], self.value, self.line, self.column)

class PreprocessorCommand(object):
	"""
	Object generated when the lexer encounters a preprocessor command.
	Used to implement e.g. type annotations.
	"""
	def __init__(self, a_command, a_arguments):
		self.command = a_command #PreprocessorCommandEnum
		self.arguments = a_arguments

# Statement objects generated by the parser.
class ElseStatement(object):
	def __init__(self):
		pass

class RepeatStatement(object):
	def __init__(self):
		pass

class BreakStatement(object):
	def __init__(self):
		pass

class DoStatement(object):
	def __init__(self):
		pass

class EndStatement(object):
	def __init__(self):
		pass

class UntilStatement(object):
	def __init__(self):
		pass

class IfStatement(object):
	def __init__(self, a_condition):
		self.condition = a_condition

class ElseIfStatement(object):
	def __init__(self, a_condition):
		self.condition = a_condition

class ReturnStatement(object):
	def __init__(self, a_expressions):
		self.expressions = a_expressions

class WhileStatement(object):
	def __init__(self, a_condition):
		self.condition = a_condition

class ForNumericStatement(object):
	def __init__(self, a_variable, a_start, a_end, a_step):
		self.variable = a_variable

class ForGenericStatement(object):
	def __init__(self, a_variables, a_iterators):
		self.variables = a_variables

class GotoStatement(object):
	def __init__(self, a_name):
		self.name = a_name

class LabelStatement(object):
	def __init__(self, a_name):
		self.name = a_name

class AssignmentStatement(object):
	def __init__(self, a_variables, a_initial_values):
		self.variables = a_variables
		self.initial_values = a_initial_values

class CallStatement(object):
	def __init__(self, a_expression):
		self.expression = a_expression

class CallExpression(object):
	def __init__(self, a_base, a_expressions):
		self.base = a_base
		self.expressions = a_expressions

class TableCallExpression(object):
	def __init__(self, a_base, a_table):
		self.base = a_base
		self.table = a_table

class StringCallExpression(object):
	def __init__(self, a_base, a_expression):
		self.base = a_base
		self.expression = a_expression

class TableKey(object):
	def __init__(self, a_key, a_value):
		self.key = a_key
		self.value = a_value

class TableKeyString(object):
	def __init__(self, a_key, a_value):
		self.key = a_key
		self.value = a_value

class TableValue(object):
	def __init__(self, a_value):
		self.value = a_value

class TableConstructorExpression(object):
	def __init__(self, a_fields):
		self.fields = a_fields

class LocalVariables(object):
	def __init__(self, a_variables):
		self.variables = a_variables

class IndexExpression(object):
	def __init__(self, a_base, a_expression):
		self.base = a_base
		self.expression = a_expression

class MemberExpression(object):
	def __init__(self, a_base, a_operator_type, a_identifier):
		self.operator_type = a_operator_type
		self.base = a_base
		self.identifier = a_identifier

	def __str__(self):
		if self.operator_type == TokenEnum.DOT:
			return "%s.%s" % (self.base, self.identifier)
		elif self.operator_type == TokenEnum.COLON:
			return "%s:%s" % (self.base, self.identifier)

class Literal(object):
	def __init__(self, a_type, a_value):
		self.type = a_type
		self.value = a_value

class Identifier(object):
	def __init__(self, a_value):
		self.value = a_value

	def __str__(self):
		return self.value

class FunctionSignature(object):
	def __init__(self, a_name, a_parameters, a_is_local):
		self.name = a_name
		self.parameters = a_parameters

class UnaryExpression(object):
	def __init__(self, a_operator_type, a_argument):
		self.operator_type = a_operator_type
		self.expression = a_argument

class BinaryExpression(object):
	def __init__(self, a_operator_type, a_expression, a_right):
		self.operator_type = a_operator_type
		self.left_expression = a_expression
		self.right_expression = a_right

class NodeResult(object):
	"""
	Object used by the node_visitor function to pass information while recursively walking through an AST's
	nodes.
	"""
	def __init__(self, a_type, a_calling_function):
		self.type = a_type
		self.calling_function = a_calling_function

	def __str__(self):
		return str(self.type)

# Custom exceptions raised by the lexer and parser.
class LexingError(Exception):
	def __init__(self, a_message, a_line, a_column, a_character):
		super(LexingError, self).__init__()
		self.message = a_message
		self.line = a_line
		self.column = a_column
		self.character = a_character

class ParsingError(Exception):
	def __init__(self, a_message, a_line, a_column):
		super(ParsingError, self).__init__()
		self.message = a_message
		self.line = a_line
		self.column = a_column

class ExpectedFunctionParameterExpressionError(ParsingError):
	def __init__(self, a_message, a_line, a_column, a_function, a_nth_parameter):
		super(ExpectedFunctionParameterExpressionError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column
		self.function = a_function
		self.nth_parameter = a_nth_parameter

class ExpectedExpressionError(ParsingError):
	def __init__(self, a_message, a_line, a_column):
		super(ExpectedExpressionError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column

class ExpectedNameError(ParsingError):
	def __init__(self, a_message, a_line, a_column, a_base, a_preceding_operator_type):
		super(ExpectedNameError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column
		self.base = a_base
		self.preceding_operator_type = a_preceding_operator_type

class ExpectedPreprocessorTypeArgumentError(ParsingError):
	def __init__(self, a_message, a_line, a_column):
		super(ExpectedPreprocessorTypeArgumentError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column

# Lua types
class LuaVariable(object):
	def __init__(self, a_name, a_value = None, a_type = None):
		self._name = a_name
		self._value = None
		self._description = ""
		self._type = a_type

	def __str__(self):
		if self._type:
			return self._type
		else:
			return "variable"

	def get_name(self):
		return self._name

	def get_value(self):
		return self._value

	def get_description(self):
		return self._description

class LuaNil(LuaVariable):
	def __init__(self, a_name):
		super(LuaNil, self).__init__(a_name, None)
		self._name = a_name
		self._value = None

	def __str__(self):
		return "nil"

class LuaBoolean(LuaVariable):
	def __init__(self, a_name, a_value):
		super(LuaBoolean, self).__init__(a_name, a_value)
		assert isinstance(a_value, bool)
		self._name = a_name
		self._value = a_value

	def __str__(self):
		return "boolean"

class LuaNumber(LuaVariable):
	def __init__(self, a_name, a_value):
		super(LuaNumber, self).__init__(a_name, a_value)
		if not isinstance(a_value, int):
			assert isinstance(a_value, float)
		self._name = a_name
		self._value = a_value

	def __str__(self):
		return "number"

class LuaString(LuaVariable):
	def __init__(self, a_name, a_value):
		super(LuaString, self).__init__(a_name, a_value)
		if PYTHON_VERSION[0] == 2:
			if not isinstance(a_value, str):
				assert isinstance(a_value, unicode)
		elif PYTHON_VERSION[0] >= 3:
			assert isinstance(a_value, str)
		self._name = a_name
		self._value = a_value

	def __str__(self):
		return "string"

class LuaFunction(LuaVariable):
	def __init__(self, a_name, a_parameters=[], a_return_types=[]):
		super(LuaFunction, self).__init__(a_name, None)
		self._name = a_name
		self._value = None
		self._type = None
		self._parameters = a_parameters
		self._return_types = a_return_types

	def __str__(self):
		if self._type:
			return self._type
		else:
			return "function"

	def add_parameter(self, a_param):
		pass

	def get_parameters(self):
		return self._parameters

	def get_return_types(self):
		return self._return_types

class LuaTable(LuaVariable):
	def __init__(self, a_name, a_fields = []):
		super(LuaTable, self).__init__(a_name, None)
		self._name = a_name
		self._value = None
		self._type = ""
		self._fields = {}
		self._inherited_fields = None
		if a_fields:
			i = 1
			for field in a_fields:
				if isinstance(field, TableKey):
					self.set_field(field.value, field.key)
				elif isinstance(field, TableKeyString):
					self.set_field(field.value, field.key)
				elif isinstance(field, TableValue):
					self.set_field(field.value, i)
					i += 1

	def __str__(self):
		if self._type != "":
			return self._type
		else:
			return "table"

	def __deepcopy__(self, memo):
		obj = LuaTable(self._name)
		obj._value = copy.deepcopy(self._value, memo)
		obj._type = copy.deepcopy(self._type, memo)
		obj._fields = copy.deepcopy(self._fields, memo)
		obj._inherited_fields = self._inherited_fields
		return obj

	def has_field(self, a_key):
		if self.get_field(a_key):
			return True
		return False

	def get_field(self, a_key):
		exists = self._fields.get(a_key, None)
		if not exists and self._inherited_fields:
			exists = self._inherited_fields.get(a_key, None)
		return exists

	def set_field(self, a_value, a_key):
		if isinstance(a_key, Literal) or isinstance(a_key, Identifier):
			self._fields[a_key.value] = a_value
		else:
			self._fields[a_key] = a_value

	def get_fields(self):
		for key, value in self._fields.items():
			yield key, value
		if self._inherited_fields:
			for key, value in self._inherited_fields.items():
				yield key, value

#class LuaUserdata(LuaVariable):
#	def __init__(self, a_name):
#		super(LuaVariable, self).__init__(a_name, None)
#		self._name = a_name
#		self._value = None

class LuaThread(LuaVariable):
	def __init__(self, a_name):
		super(LuaThread, self).__init__(a_name, None)
		self._name = a_name
		self._value = None

class Parser(object):
	def __init__(self):
		# Regex patterns used to generate tokens.
		token_specifications = [
			(TokenEnum.PREPROCESSOR_COMMAND, r"\-\-\@[^\n\r]*"), # Specific to this parser. Not a part of the Lua language specification!
			(TokenEnum.BLOCK_COMMENT, r"\-\-\[\[.*?\]\]"),
			(TokenEnum.LINE_COMMENT, r"\-\-[^\n\r]*"),
			(TokenEnum.NAME, r"[_a-zA-Z][_a-zA-Z0-9]*"),
			(TokenEnum.DOUBLE_COLON, r"::"),
			(TokenEnum.COLON, r":"),
			(TokenEnum.COMMA, r","),
			(TokenEnum.LEFT_BRACKET, r"\["),
			(TokenEnum.LEFT_CURLY_BRACE, r"\{"),
			(TokenEnum.LEFT_PARENTHESIS, r"\("),
			(TokenEnum.RIGHT_BRACKET, r"\]"),
			(TokenEnum.RIGHT_CURLY_BRACE, r"\}"),
			(TokenEnum.RIGHT_PARENTHESIS, r"\)"),
			(TokenEnum.OP_ADD, r"\+"),
			(TokenEnum.OP_BIT_AND, r"&"),
			(TokenEnum.OP_BIT_LSHIFT, r"<<"),
			(TokenEnum.OP_LESS_THAN_OR_EQUAL, r"<="),
			(TokenEnum.OP_LESS, r"<"),
			(TokenEnum.OP_BIT_OR, r"\|"),
			(TokenEnum.OP_BIT_RSHIFT, r">>"),
			(TokenEnum.OP_GREATER_THAN_OR_EQUAL, r">="),
			(TokenEnum.OP_GREATER, r">"),
			(TokenEnum.OP_EQUAL, r"=="),
			(TokenEnum.OP_NOT_EQUAL, r"~="),
			(TokenEnum.OP_BIT_NOT_XOR, r"~"),
			(TokenEnum.OP_ASSIGN, r"="),
			(TokenEnum.OP_IDIV, r"//"),
			(TokenEnum.OP_DIV, r"/"),
			(TokenEnum.OP_LEN, r"#"),
			(TokenEnum.OP_MOD, r"\%"),
			(TokenEnum.OP_MUL, r"\*"),
			(TokenEnum.OP_POW, r"\^"),
			(TokenEnum.OP_SUB, r"\-"),
			(TokenEnum.SEMICOLON, r";"),
			(TokenEnum.VARARG, r"\.\.\."),
			(TokenEnum.OP_CONCAT, r"\.\."),
			(TokenEnum.DOT, r"\."),
			(TokenEnum.NEWLINE, r"[\n\r]"),
			(TokenEnum.WHITESPACE, r"[ \t]"),
			(TokenEnum.STRING, r"(?:(?<!\\)\'.*?(?:(?:\\\\\')|(?<!\\)\'))|(?:(?<!\\)\".*?(?:(?:\\\\\")|(?<!\\)\"))"),
			(TokenEnum.NUMBER, r"0[xX][0-9a-fA-F]+[pP][+-]?[0-9]+|0[xX]\.[0-9a-fA-F]+(?:[pP][+-]?[0-9]+)?|0[xX][0-9a-fA-F]+(?:\.[0-9a-fA-F]*(?:[pP][+-]?[0-9]+)?)?|[0-9]+(?:[eE][+-]?[0-9]+)|\.[0-9]+(?:[eE][+-]?[0-9]+)?|[0-9]+(?:\.[0-9]*(?:[eE][+-]?[0-9]+)?)?"),
			(TokenEnum.UNMATCHED, r"."),
		]
		self.token_regex = re.compile("|".join("(?P<t%s>%s)" % pair for pair in token_specifications), re.DOTALL)
		# Regex patterns used to match Lua keywords when a TokenEnum.NAME token has been generated.
		keyword_specifications = [
			(TokenEnum.KW_AND, r"and"),
			(TokenEnum.KW_BREAK, r"break"),
			(TokenEnum.KW_DO, r"do"),
			(TokenEnum.KW_ELSEIF, r"elseif"),
			(TokenEnum.KW_ELSE, r"else"),
			(TokenEnum.KW_END, r"end"),
			(TokenEnum.KW_FALSE, r"false"),
			(TokenEnum.KW_FOR, r"for"),
			(TokenEnum.KW_FUNCTION, r"function"),
			(TokenEnum.KW_GOTO, r"goto"),
			(TokenEnum.KW_IF, r"if"),
			(TokenEnum.KW_IN, r"in"),
			(TokenEnum.KW_LOCAL, r"local"),
			(TokenEnum.KW_NIL, r"nil"),
			(TokenEnum.KW_NOT, r"not"),
			(TokenEnum.KW_OR, r"or"),
			(TokenEnum.KW_REPEAT, r"repeat"),
			(TokenEnum.KW_RETURN, r"return"),
			(TokenEnum.KW_THEN, r"then"),
			(TokenEnum.KW_TRUE, r"true"),
			(TokenEnum.KW_UNTIL, r"until"),
			(TokenEnum.KW_WHILE, r"while"),
		]
		self.keyword_regex = re.compile("|".join("(?P<t%s>^%s$)" % pair for pair in keyword_specifications))
		# Regex pattern used to match type annotation preprocessor commands.
		self.preprocessor_command_type_annotation_regex = re.compile(
			"^(?:(?P<variable_types>[_a-zA-Z0-9, \t]+))?(?:\s*\-\>\s*(?P<return_types>[_a-zA-Z0-9, \t]+))?",
			re.MULTILINE)
		# JSON-compatible object containing information scraped from the Afterbirth+ API.
		self.afterbirth_api = None
		# The base scope that is generated once from the information in self.afterbirth_api
		self.base_api_scope = None
		self.api_classes = None
		self.api_enums = None
		self.standard_libraries_scope = None

	#@timed
	def preprocessor_commands(self, a_command_string, a_line, a_column):
		a_command_string = a_command_string.strip()
		if a_command_string == "":
			raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line, a_column)
		elif a_command_string == "->":
			raise ExpectedPreprocessorTypeArgumentError("Expected a return type annotation", a_line, a_column)
		command_match = self.preprocessor_command_type_annotation_regex.match(a_command_string)
		if command_match:
			variable_types = command_match.group("variable_types")
			if variable_types:
				arguments = [type_.strip() for type_ in variable_types.split(",")]
				for arg in arguments:
					if arg == "":
						raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line,
							a_column)
				yield PreprocessorCommand(PreprocessorCommandEnum.VARIABLE_TYPES, arguments)
			return_types = command_match.group("return_types")
			if return_types:
				arguments = [type_.strip() for type_ in return_types.split(",")]
				for arg in arguments:
					if arg == "":
						raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line,
							a_column)
				yield PreprocessorCommand(PreprocessorCommandEnum.RETURN_TYPES, arguments)
			elif "->" in a_command_string:
				raise ExpectedPreprocessorTypeArgumentError("Expected a return type annotation", a_line,
					a_column)
		else:
			raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line, a_column)

	#@timed
	def tokenize(self, a_source_code, a_starting_line_index):
		line = 1 + a_starting_line_index
		column = -1
		for match in self.token_regex.finditer(a_source_code):
			type_ = match.lastgroup
			value_ = match.group(type_)
			type_ = int(match.lastgroup[1:])
			if type_ == TokenEnum.WHITESPACE:
				continue
			elif type_ == TokenEnum.NAME:
				keyword = self.keyword_regex.match(value_)
				if keyword:
					type_ = int(keyword.lastgroup[1:])
			elif type_ == TokenEnum.BLOCK_COMMENT:
				i = value_.count("\n")
				if i > 0:
					line += i
					column = match.end()-1
				continue
			elif type_ == TokenEnum.LINE_COMMENT:
				continue
			elif type_ == TokenEnum.STRING:
				value_ = value_[1:-1]
				yield Token(type_, value_, line, match.start()-column)
				i = value_.count("\n")
				if i > 0:
					line += i
					column = match.end()-1
				continue
			elif type_ == TokenEnum.NEWLINE:
				line += 1
				column = match.end()-1
			elif type_ == TokenEnum.PREPROCESSOR_COMMAND:
				value_ = value_[3:]
				for command in self.preprocessor_commands(value_, line, match.start()-column):
					yield Token(TokenEnum.PREPROCESSOR_COMMAND, command, line, match.start()-column)
				continue
			elif type_ == TokenEnum.UNMATCHED:
				raise LexingError("Encountered an unexpected character ('%s')" % value_,
					line, match.start()-column, value_)
			yield Token(type_, value_, line, match.start()-column)
		yield Token(TokenEnum.EOF, "\n", line, 1)

	#@timed
	def generate_api_scope(self):
		generated_functions = []
		generated_tables = []
		def parse_function_to_lua(a_function_key, a_function):
			returns = a_function.get(APIKeyEnum.RETURNS, [])
			if returns:
				returns = returns.get(APIKeyEnum.TYPE, [])
				if returns: # API functions only seem to return one value
					returns = [returns]
			parameters = []
			i = 1
			for param in a_function.get(APIKeyEnum.PARAMETERS, []):
				param_name = param.get(APIKeyEnum.NAME, "param%s" % i)
				if param_name == "":
					param_name = "param%s" % i
				lua_var = LuaVariable(param_name, a_type=param.get(APIKeyEnum.TYPE, None))
				parameters.append(lua_var)
				i += 1
			lua_func = LuaFunction(a_function_key, parameters, returns)
			generated_functions.append(lua_func)
			lua_func._description = a_function.get(APIKeyEnum.DESCRIPTION, "")
			return lua_func

		api = {}
		# Classes
		self.api_classes = {}
		self.api_enums = {}
		for class_key, class_ in self.afterbirth_api.get(APIKeyEnum.CLASSES, {}).items():
			lua_table = LuaTable(class_key)
			generated_tables.append(lua_table)
			constructor = None
			for function_key, function in class_.get(APIKeyEnum.FUNCTIONS, {}).items():
				lua_func = parse_function_to_lua(function_key, function)
				if not constructor and function_key == class_key:
					constructor = lua_func
					constructor._type = "constructor"
				else:
					lua_table.set_field(lua_func, function_key)
			for attribute_key, attribute in class_.get(APIKeyEnum.ATTRIBUTES, {}).items():
				lua_var = LuaVariable(attribute_key, a_type=attribute.get(APIKeyEnum.TYPE, None))
				lua_table.set_field(lua_var, attribute_key)
			if constructor:
				api[class_key] = constructor # Constructor that is available to the mod author
			self.api_classes[class_key] = lua_table # A Lua table-like object that contains all class attributes and methods
		# group___functions
		for function_key, function in self.afterbirth_api.get(APIKeyEnum.FUNCTIONS, {}).items():
			if function_key.startswith("Isaac::"):
				function_key = function_key[7:]
			lua_func = parse_function_to_lua(function_key, function)
			api[function_key] = lua_func
		# Enums
		for enum_key, enum in self.afterbirth_api.get(APIKeyEnum.ENUMS, {}).items():
			lua_table = LuaTable(enum_key)
			i = 0
			for member in enum.get(APIKeyEnum.MEMBERS, []):
				#TODO
				# 'i' is not actually the real value in all cases, mostly just as a placeholder
				# The actual value should be scraped from the API documentation
				lua_table.set_field(LuaNumber(member[APIKeyEnum.NAME], i), member[APIKeyEnum.NAME])
				i += 1
			lua_table._type = "enum"
			if api.get(enum_key, False):
				SharedFunctions.debug_print("%s is already in the API, overriding with an enum"
					% enum_key, api[enum_key])
			api[enum_key] = lua_table
			self.api_enums[enum_key] = lua_table
		# Namespaces
		for namespace_key, namespace in self.afterbirth_api.get(APIKeyEnum.NAMESPACES, {}).items():
			if namespace_key == "Isaac":
				lua_table = LuaTable(namespace_key)
				generated_tables.append(lua_table)
				mod_table = LuaTable("Mod")
				mod_functions = {}
				mod_functions_list = ["AddCallback", "HasModData", "LoadModData", "RegisterMod",
					"RemoveModData", "SaveModData"]
				generated_tables.append(mod_table)
				for function_key, function in namespace.get(APIKeyEnum.FUNCTIONS, {}).items():
					if function_key in mod_functions_list:
						mod_functions[function_key] = function
						del function[APIKeyEnum.PARAMETERS][0]
					else:
						lua_func = parse_function_to_lua(function_key, function)
						lua_table.set_field(lua_func, function_key)
				if api.get(namespace_key, False):
					SharedFunctions.debug_print("%s is already in the API, overriding with a namespace"
						% namespace_key, api[namespace_key])
				api[namespace_key] = lua_table
				# Mod stuff
				for function_key, function in mod_functions.items():
					if function_key == "RegisterMod":
						lua_func = parse_function_to_lua(function_key, function)
						lua_func._return_types = ["Mod"]
						api["RegisterMod"] = lua_func
					else:
						lua_func = parse_function_to_lua(function_key, function)
						mod_table.set_field(lua_func, function_key)
				if self.api_classes.get("Mod", None):
					SharedFunctions.debug_print(
						"Mod is already in the API classes, overriding with custom Mod class")
				self.api_classes["Mod"] = mod_table
			else:
				lua_table = LuaTable(namespace_key)
				generated_tables.append(lua_table)
				for function_key, function in namespace.get(APIKeyEnum.FUNCTIONS, {}).items():
					lua_func = parse_function_to_lua(function_key, function)
					lua_table.set_field(lua_func, function_key)
				for attribute_key, attribute in namespace.get(APIKeyEnum.ATTRIBUTES, {}).items():
					lua_var = LuaVariable(attribute_key, a_type=attribute.get(APIKeyEnum.TYPE, None))
					lua_table.set_field(lua_var, attribute_key)
				if api.get(namespace_key, False):
					SharedFunctions.debug_print("%s is already in the API, overriding with a namespace"
						% namespace_key, api[namespace_key])
				api[namespace_key] = lua_table
		# Convert all of the LuaVariable instances, which have _type != None, into corresponding LuaTable instances
		def finalize_function(a_function):
			clean = True
			new_parameters = []
			for parameter in a_function.get_parameters():
				if isinstance(parameter, LuaVariable):
					if parameter._type:
						if parameter._type == "integer" or parameter._type == "float":
							new_parameters.append(self.get_lua_variable("number", parameter.get_name()))
						else:
							new_parameters.append(self.get_lua_variable(parameter._type,
								parameter.get_name()))
						clean = False
					else:
						new_parameters.append(parameter)
				else:
					new_parameters.append(parameter)
			a_function._parameters = new_parameters
			new_return_types = []
			for return_type in a_function.get_return_types():
				if isinstance(return_type, LuaVariable):
					if return_type._type:
						if return_type._type == "integer" or return_type._type == "float":
							new_return_types.append(self.get_lua_variable("number", return_type.get_name()))
						else:
							new_return_types.append(self.get_lua_variable(return_type._type,
								return_type.get_name()))
						clean = False
					else:
						new_return_types.append(return_type)
				else:
					new_return_types.append(return_type)
			a_function._return_types = new_return_types
			return clean

		def finalize_table(a_table):
			clean = True
			for key, value in a_table.get_fields():
				if isinstance(value, LuaVariable):
					if value._type:
						if value._type == "integer" or value._type == "float":
							a_table.set_field(self.get_lua_variable("number", key), key)
						else:
							a_table.set_field(self.get_lua_variable(value._type, key), key)
						clean = False
			return clean
		# Class pass
		for class_ in generated_tables:
			finalize_table(class_)
		# Functions pass
		for function in generated_functions:
			finalize_function(function)
		return api

	#@timed
	def generate_standard_libraries_scope(self):
		standard_libraries = {}
		def convert_json_to_lua(a_library, a_name):
			lua_table = LuaTable(a_name)
			lua_table._type = "std. lib."
			for function_key, function in a_library.get(APIKeyEnum.FUNCTIONS, {}).items():
				return_types = function.get(APIKeyEnum.RETURNS, [])
				if return_types:
					return_types = [type_[APIKeyEnum.TYPE] for type_ in return_types]
				parameters = []
				i = 1
				for param in function.get(APIKeyEnum.PARAMETERS, []):
					param_name = param.get(APIKeyEnum.NAME, "param%s" % i)
					if param_name == "":
						param_name = "param%s" % i
					lua_var = LuaVariable(param_name, a_type=param.get(APIKeyEnum.TYPE, None))
					parameters.append(lua_var)
					i += 1
				lua_func = LuaFunction(function_key, parameters, return_types)
				lua_func._description = function.get(APIKeyEnum.DESCRIPTION, "")
				lua_table.set_field(lua_func, function_key)
			for attribute_key, attribute in a_library.get(APIKeyEnum.ATTRIBUTES, {}).items():
				lua_variable = self.get_lua_variable(attribute.get(APIKeyEnum.TYPE, ""), attribute_key)
				lua_table.set_field(lua_variable, attribute_key)
			return {a_name: lua_table}
		basic = convert_json_to_lua(LuaStandardLibraries.get_basic(), "basic").get("basic", None)
		if basic:
			for key, value in basic.get_fields():
				standard_libraries[key] = value
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_coroutine(), "coroutine"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_package(), "package"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_string(), "string"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_utf8(), "utf8"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_table(), "table"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_math(), "math"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_io(), "io"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_file(), "file"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_os(), "os"))
		standard_libraries.update(convert_json_to_lua(LuaStandardLibraries.get_debug(), "debug"))
		return standard_libraries

	#@timed
	def get_initial_scope(self, a_scope = None):
		# Scope structure:
		# 0 = Lua standard libraries
		# 1 = API functions, namespaces, enums, and classes.
		# 2 = Global variables and functions.
		# 3 = Script scope.
		# 4 ... n = Local scopes nested within the script scope.
		if a_scope: # Use the scope that was given as 'a_scope'.
			scope = [self.standard_libraries_scope, self.base_api_scope]
			scope.extend(a_scope)
			return scope
		else: # Generate the initial scope
			if not self.afterbirth_api: # Load Afterbirth+ API, if that has not already been done.
				self.afterbirth_api = SharedFunctions.load_afterbirth_api()
				if not self.afterbirth_api:
					SharedFunctions.error_message("Failed to load Afterbirth+ API. May require scraping")
					return None
				self.base_api_scope = self.generate_api_scope()
			if not self.standard_libraries_scope:
				self.standard_libraries_scope = self.generate_standard_libraries_scope()
			return [self.standard_libraries_scope, self.base_api_scope, {}, {}]

	#@timed
	def tokenize_lines(self, a_source_code, a_starting_line_index):
		lines = []
		tokens = []
		for token in self.tokenize(a_source_code, a_starting_line_index):
			tokens.append(token)
			if token.type == TokenEnum.NEWLINE:
				if len(tokens) > 1:
					lines.append(tokens)
				tokens = []
		if len(tokens) > 1:
			lines.append(tokens)
		return lines

	#@timed
	def parse(self, a_source_code, a_starting_line_index = 0, a_scope = None, a_completing = False):
		tokens = []
		for token in self.tokenize(a_source_code, a_starting_line_index):
			if token.type != TokenEnum.NEWLINE:
				tokens.append(token)
		self.scope = self.get_initial_scope(a_scope)
		self.tokens_to_process = tokens
		self.processed_tokens = []
		statements = []
		while self.tokens_to_process:
			line_start = self.tokens_to_process[0].line
			if self.peek(TokenEnum.EOF, 0):
				break
			elif self.consume(TokenEnum.SEMICOLON):
				pass
			statement = self.parse_statement()
			if statement:
				line_end = self.processed_tokens[-1].line
				statements.append(statement)
				#print("Generated:", self.scope[2:])
				yield ScopeCache([copy.deepcopy(scope) for scope in self.scope[2:]], line_start, line_end)
				continue
			break
		if not a_completing and self.scope and len(self.scope) > 4:
			self.raise_error(ParsingError, "Found %d unterminated scope(s)" % (len(self.scope) - 4))
		return

	#@timed
	def raise_error(self, a_error_class, a_message, a_line = None, a_column = None,
		a_additional_arguments = []):
		if self.processed_tokens:
			if a_line:
				raise a_error_class(a_message, a_line, 0, *a_additional_arguments)
			else:
				raise a_error_class(a_message, self.processed_tokens[-1].line,
					self.processed_tokens[-1].column, *a_additional_arguments)
		elif self.tokens_to_process:
			if a_line:
				raise a_error_class(a_message, a_line, 0, *a_additional_arguments)
			else:
				raise a_error_class(a_message, self.tokens_to_process[0].line,
					self.tokens_to_process[0].column, *a_additional_arguments)

	#@timed
	def next(self):
		if self.tokens_to_process:
			self.processed_tokens.append(self.tokens_to_process.pop(0))
		else:
			self.raise_error(ParsingError, "Nothing more to parse")

	#@timed
	def consume(self, a_token_type):
		if self.tokens_to_process[0].type == a_token_type:
			self.next()
			return True
		return False

	#@timed
	def peek(self, a_token_type, a_amount):
		if len(self.tokens_to_process) >= a_amount + 1:
			if self.tokens_to_process[a_amount].type == a_token_type:
				return True
		return False

	#@timed
	def expect(self, a_token_type):
		if self.tokens_to_process[0].type == a_token_type:
			self.next()
		else:
			self.raise_error(ParsingError, "Expected %s, got %s instead" % (TOKEN_DESCRIPTION[a_token_type],
				TOKEN_DESCRIPTION[self.tokens_to_process[0].type]))

	#@timed
	def push_to_scope(self, a_lua_variable, a_is_local = False):
		assert isinstance(a_lua_variable, LuaVariable)
		name = a_lua_variable.get_name()#str(a_dict[APIKeyEnum.NAME])
		if self.scope[0].get(name, None):
			self.raise_error(ParsingError, "'%s' is a name reserved by the Lua standard libraries" % name)
		elif self.scope[1].get(name, None):
			self.raise_error(ParsingError, "'%s' is a name reserved by the Afterbirth+ API" % name)
		if a_is_local:
			self.scope[-1][name] = a_lua_variable
		else:
			modified = False
			for scope in reversed(self.scope):
				if scope.get(name, None):
					modified = True
					scope[name] = a_lua_variable
					break
			if not modified:
				self.scope[2][name] = a_lua_variable

	#@timed
	def is_variable_in_scope(self, a_name):
		a_name = str(a_name)
		exists = self.is_in_scope(a_name)
		if exists:
			if isinstance(exists, LuaVariable):
				return exists
		return None

	#@timed
	def is_in_scope(self, a_name):
		#a_name = str(a_name)
		if not self.scope:
			return None
		for scope in reversed(self.scope):
			existing = scope.get(a_name, None)
			if existing:
				return existing
		return None

	#@timed
	def create_scope(self):
		self.scope.append({})

	#@timed
	def destroy_scope(self):
		if len(self.scope) > 4:
			self.scope.pop()
		else:
			self.raise_error(ParsingError, "No scope to end")

	#@timed
	def parse_line(self):
		statements = []
		while (self.tokens_to_process[0].type != TokenEnum.NEWLINE
			and self.tokens_to_process[0].type != TokenEnum.EOF):
			statement = self.parse_statement()
			if statement:
				statements.append(statement)
		return statements

	#@timed
	def parse_statement(self):
		if self.consume(TokenEnum.KW_LOCAL):
			return self.parse_local_statement()
		elif self.consume(TokenEnum.KW_IF):
			self.create_scope()
			return self.parse_if_statement()
		elif self.consume(TokenEnum.KW_ELSEIF):
			self.destroy_scope()
			self.create_scope()
			return self.parse_elseif_statement()
		elif self.consume(TokenEnum.KW_ELSE):
			self.destroy_scope()
			self.create_scope()
			return ElseStatement()
		elif self.consume(TokenEnum.KW_RETURN):
			return self.parse_return_statement()
		elif self.consume(TokenEnum.KW_FUNCTION):
			name = self.parse_function_name()
			return self.parse_function_declaration(name, False)
		elif self.consume(TokenEnum.KW_WHILE):
			self.create_scope()
			return self.parse_while_statement()
		elif self.consume(TokenEnum.KW_FOR):
			self.create_scope()
			return self.parse_for_statement()
		elif self.consume(TokenEnum.KW_REPEAT):
			self.create_scope()
			return RepeatStatement()
		elif self.consume(TokenEnum.KW_BREAK):
			return BreakStatement()
		elif self.consume(TokenEnum.KW_DO):
			self.create_scope()
			return DoStatement()
		elif self.consume(TokenEnum.KW_GOTO):
			return self.parse_goto_statement()
		elif self.consume(TokenEnum.KW_END):
			self.destroy_scope()
			return EndStatement()
		elif self.consume(TokenEnum.KW_UNTIL):
			self.destroy_scope()
			return UntilStatement()
		elif self.consume(TokenEnum.DOUBLE_COLON):
			return self.parse_label_statement()
		elif self.consume(TokenEnum.SEMICOLON):
			return None
		elif self.consume(TokenEnum.PREPROCESSOR_COMMAND):
			return None
		return self.parse_assignment_or_call_statement()

	#@timed
	def get_lua_variable(self, a_type_string, a_name):
		var = {
			"nil": LuaNil(a_name),
			"boolean": LuaBoolean(a_name, False),
			"number": LuaNumber(a_name, 0),
			"string": LuaString(a_name, ""),
			"function": LuaFunction(a_name),
			"table": LuaTable(a_name),
			"thread": LuaThread(a_name)
			#"userdata": LuaUserdata(a_name)
		}.get(a_type_string, None)
		if not var:
			class_ = self.api_classes.get(a_type_string, None)
			if class_:
				var = LuaTable(a_name)
				var._inherited_fields = class_._fields
				var._type = class_.get_name()
			else:
				enum = self.api_enums.get(a_type_string, None)
				if enum:
					var = LuaVariable(a_name)
					#var._inherited_fields = enum._fields
					var._type = enum.get_name()
				else:
					if self.standard_libraries_scope:
						standard_library_object = self.standard_libraries_scope.get(a_type_string, None)
						if standard_library_object:
							var = LuaTable(a_name)
							var._inherited_fields = standard_library_object._fields
							var._type = standard_library_object.get_name()
						else:
							var = LuaVariable(a_name)
					else:
						var = LuaVariable(a_name)
		return var

	#@timed
	def parse_local_statement(self):
		if self.peek(TokenEnum.NAME, 0): # Variable(s)
			variables = []
			initial_values = []
			name = self.parse_identifier()
			variables.append(name)
			while self.consume(TokenEnum.COMMA):
				name = self.parse_identifier()
				variables.append(name)
			if self.consume(TokenEnum.OP_ASSIGN):
				init_expr = self.parse_expected_expression()
				init_val = self.node_visitor(init_expr)
				if isinstance(init_val, list):
					initial_values.extend(init_val)
				else:
					initial_values.append(init_val)
				while self.consume(TokenEnum.COMMA):
					init_expr = self.parse_expected_expression()
					init_val = self.node_visitor(init_expr)
					if isinstance(init_val, list):
						initial_values.extend(init_val)
					else:
						initial_values.append(init_val)
			# Optional type annotation
			variable_types = []
			if self.consume(TokenEnum.PREPROCESSOR_COMMAND):
				value = self.processed_tokens[-1].value
				if value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
					for type_ in value.arguments:
						variable_types.append(type_)
			# Figure out corresponding Lua* class
			final_variables = []
			i = 0
			variable_types_count = len(variable_types)
			initial_values_count = len(initial_values)
			for var in variables:
				if i < variable_types_count:
					lua_var = self.get_lua_variable(variable_types[i], str(var))
					if lua_var:
						final_variables.append(lua_var)
					else:
						final_variables.append(LuaVariable(str(var)))
						SharedFunctions.debug_print(
							"Could not figure out local variable type based on type annotation %s"
							% variable_types[i])
				elif i < initial_values_count:
					lua_var = initial_values[i]
					if lua_var:
						lua_var._name = str(var)
						final_variables.append(lua_var)
					else:
						final_variables.append(LuaVariable(str(var)))
						SharedFunctions.debug_print(
							"Could not figure out local variable type based on initial value %s"
							% initial_values[i])
				else:
					final_variables.append(LuaNil(str(var)))
				i += 1
			# Add variables to scope
			for var in final_variables:
				self.push_to_scope(var, True)
			return LocalVariables(final_variables)
		elif self.consume(TokenEnum.KW_FUNCTION):
			name = self.parse_identifier()
			return self.parse_function_declaration(name, True)
		else:
			self.raise_error(ParsingError, "Incomplete local statement")

	#@timed
	def parse_if_statement(self):
		condition = self.parse_expected_expression()
		self.expect(TokenEnum.KW_THEN)
		return IfStatement(condition)

	#@timed
	def parse_elseif_statement(self):
		condition = self.parse_expected_expression()
		self.expect(TokenEnum.KW_THEN)
		return ElseIfStatement(condition)

	#@timed
	def parse_return_statement(self):
		expressions = []
		expression = self.parse_expression()
		if expression:
			expressions.append(expression)
		while self.consume(TokenEnum.COMMA):
			expression = self.parse_expected_expression()
			expressions.append(expression)
		return ReturnStatement(expressions)

	#@timed
	def is_base_type(self, a_type):
		return {
			"boolean": True,
			"nil": True,
			"string": True,
			"number": True,
			"table": True
		}.get(str(a_type), False)

	#@timed
	def parse_function_name(self):
		base = self.parse_identifier()
		current_type = None
		if not self.peek(TokenEnum.LEFT_PARENTHESIS, 0):
#			print(str(base))
			current_type = self.is_variable_in_scope(base)
			if not current_type:
				self.raise_error(ParsingError, "'%s' is not a known variable" % base)
		while self.consume(TokenEnum.DOT):
			name = self.parse_identifier()
			if not name:
				self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=TokenEnum.DOT)
			base = MemberExpression(base, TokenEnum.DOT, name)
		if self.consume(TokenEnum.COLON):
			name = self.parse_identifier()
			if not name:
				self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=TokenEnum.COLON)
			base = MemberExpression(base, TokenEnum.COLON, name)
		return base

	#@timed
	def parse_function_declaration(self, a_name, a_is_local):
		parameters = []
		self.expect(TokenEnum.LEFT_PARENTHESIS)
		if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
			while True:
				if self.peek(TokenEnum.NAME, 0):
					parameter = self.parse_identifier()
					parameters.append(parameter)
					if self.consume(TokenEnum.COMMA):
						continue
					elif self.consume(TokenEnum.RIGHT_PARENTHESIS):
						break
				elif self.consume(TokenEnum.VARARG):
					parameters.append("...")
					self.expect(TokenEnum.RIGHT_PARENTHESIS)
					break
				else:
					self.raise_error(ParsingError, "Expected a function parameter")
		# Optional type annotation
		parameter_types = []
		return_types = []
		while self.consume(TokenEnum.PREPROCESSOR_COMMAND):
			value = self.processed_tokens[-1].value
			if not parameter_types and value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
				for type_ in value.arguments:
					parameter_types.append(type_)
			elif not return_types and value.command == PreprocessorCommandEnum.RETURN_TYPES:
				for type_ in value.arguments:
					return_types.append(type_)
		# Figure out corresponding Lua* class
		final_parameters = []
		i = 0
		parameter_types_count = len(parameter_types)
		for param in parameters:
			if param == "...":
				final_parameters.append(LuaTable("arg", [TableKeyString("n", LuaNumber("n", 0))]))
				break
			else:
				if i < parameter_types_count:
					lua_var = self.get_lua_variable(parameter_types[i], str(param))
					if lua_var:
						final_parameters.append(lua_var)
					else:
						final_parameters.append(LuaVariable(str(param)))
						SharedFunctions.debug_print(
							"Could not figure out function parameter type based on type annotation %s"
							% parameter_types[i])
				else:
					final_parameters.append(LuaVariable(str(param)))
			i += 1
		final_return_types = []
		for type_ in return_types:
			lua_var = self.get_lua_variable(type_, "")
			if lua_var:
				final_return_types.append(lua_var)
			else:
				lua_var = LuaVariable(type_)
				lua_var._type = type_
				final_return_types.append(lua_var)
				SharedFunctions.debug_print(
					"Could not figure out function return type based on type annotation %s"
					% type_)
		# Get the function name and figure out if this function should be a field in a table
		name = None
		lua_function = None
		function_belongs_to_table = False
		table = None
		if isinstance(a_name, Identifier):
			name = str(a_name)
			lua_function = LuaFunction(name, final_parameters, final_return_types)
		elif isinstance(a_name, MemberExpression):# and a_name.operator_type == TokenEnum.COLON:
			name = str(a_name.identifier)
			lua_function = LuaFunction(name, final_parameters, final_return_types)

			def get_table(a_base):
				if isinstance(a_base, MemberExpression):
					t = get_table(a_base.base)
					field = t.get_field(str(a_base.identifier))
					if field:
						if isinstance(field, LuaTable):
							return field
						else:
							self.raise_error(ParsingError, "'%s' is not a table" % a_base.identifier)
					else:
						self.raise_error(ParsingError, "'%s' does not have a field called '%s'"
							% (a_base.base, a_base.identifier))
				elif isinstance(a_base, Identifier):
					t = self.is_variable_in_scope(a_base)
					if t:
						if isinstance(t, LuaTable):
							return t
						else:
							self.raise_error(ParsingError, "'%s' is not a table" % a_base)
					else:
						self.raise_error(ParsingError, "'%s' is not a variable that exists" % a_base)

			table = get_table(a_name.base)
			table.set_field(lua_function, name)
			function_belongs_to_table = True
		# Add function to scope
		if not function_belongs_to_table:
			self.push_to_scope(lua_function, a_is_local)
		self.create_scope()
		# Add parameters to scope
		if table:
			def implicitly_declare_self(a_function_name, a_parameters):
				for param in a_parameters:
					if param.get_name() == "self":
						return False
				base = a_function_name
				while isinstance(base, MemberExpression):
					if base.operator_type == TokenEnum.COLON:
						return True
					base = base.identifier
				return False

			if implicitly_declare_self(a_name, final_parameters):
				self_table = LuaTable("self")
				self_table._value = table._value
				self_table._type = table._type
				self_table._fields = table._fields
				self_table._inherited_fields = table._inherited_fields
				self.push_to_scope(self_table, True)
		for param in final_parameters:
			self.push_to_scope(param, True)
		return FunctionSignature(a_name, parameters, a_is_local)

	#@timed
	def parse_while_statement(self):
		condition = self.parse_expected_expression()
		self.expect(TokenEnum.KW_DO)
		return WhileStatement(condition)

	#@timed
	def parse_for_statement(self):
		variable = self.parse_identifier()
		if self.consume(TokenEnum.OP_ASSIGN):
			start = self.parse_expected_expression()
			self.expect(TokenEnum.COMMA)
			end = self.parse_expected_expression()
			step = None
			if self.consume(TokenEnum.COMMA):
				step = self.parse_expected_expression()
			self.expect(TokenEnum.KW_DO)
			lua_var = LuaNumber(str(variable), 0)
			self.push_to_scope(lua_var, True)
			return ForNumericStatement(lua_var, start, end, step)
		else:
			variables = [variable]
			while self.consume(TokenEnum.COMMA):
				variable = self.parse_identifier()
				variables.append(variable)
			self.expect(TokenEnum.KW_IN)
			iterators = [self.parse_expected_expression()]
			while self.consume(TokenEnum.COMMA):
				iterators.append(self.parse_expected_expression())
			self.expect(TokenEnum.KW_DO)
			variable_types = []
			if self.consume(TokenEnum.PREPROCESSOR_COMMAND):
				value = self.processed_tokens[-1].value
				if value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
					for arg in value.arguments:
						variable_types.append(arg)
			final_variables = []
			i = 0
			variable_types_count = len(variable_types)
			for var in variables:
				if i < variable_types_count:
					lua_var = self.get_lua_variable(variable_types[i], str(var))
					final_variables.append(lua_var)
				else:
					final_variables.append(LuaVariable(str(var)))
				i += 1
			for var in final_variables:
				self.push_to_scope(var, True)
			return ForGenericStatement(final_variables, iterators)

	#@timed
	def parse_goto_statement(self):
		name = self.parse_identifier()
		return GotoStatement(name)

	#@timed
	def parse_label_statement(self):
		name = self.parse_identifier()
		self.expect(TokenEnum.DOUBLE_COLON)
		return LabelStatement(name)

	#@timed
	def parse_assignment_or_call_statement(self):
		expression = self.parse_prefix_expression()
		if self.peek(TokenEnum.COMMA, 0) or self.peek(TokenEnum.OP_ASSIGN, 0):
			if not expression:
				self.raise_error(ParsingError, "Expected an expression")
			variables = [expression]
			while self.consume(TokenEnum.COMMA):
				exp = self.parse_prefix_expression()
				if not expression:
					self.raise_error(ParsingError, "Expected an expression")
				variables.append(exp)
			self.expect(TokenEnum.OP_ASSIGN)
			initial_values = []
			init_expr = self.parse_expected_expression()
			init_val = self.node_visitor(init_expr)
			if isinstance(init_val, list):
				initial_values.extend(init_val)
			else:
				initial_values.append(init_val)
			while self.consume(TokenEnum.COMMA):
				init_expr = self.parse_expected_expression()
				init_val = self.node_visitor(init_expr)
				if isinstance(init_val, list):
					initial_values.extend(init_val)
				else:
					initial_values.append(init_val)
			variable_types = []
			if self.consume(TokenEnum.PREPROCESSOR_COMMAND):
				value = self.processed_tokens[-1].value
				if value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
					for arg in value.arguments:
						variable_types.append(arg)
			final_variables = []
			i = 0
			variable_types_count = len(variable_types)
			initial_values_count = len(initial_values)
			for var in variables:
				if isinstance(var, Identifier):
					if i < variable_types_count:
						lua_var = self.get_lua_variable(variable_types[i], str(var))
						final_variables.append(lua_var)
					elif i < initial_values_count:
						lua_var = initial_values[i]
						lua_var._name = str(var)
						final_variables.append(lua_var)
					else:
						final_variables.append(LuaNil(str(var)))
				elif isinstance(var, IndexExpression):
					lua_table = self.node_visitor(var.base)
					index = self.node_visitor(var.expression)
					if i < variable_types_count:
						if isinstance(lua_table, LuaTable):
							lua_table.set_field(self.get_lua_variable(variable_types[i], index.get_value()), index.get_value())
					elif i < initial_values_count:
						lua_var = initial_values[i]
						lua_var._name = index.get_value()
						if isinstance(lua_table, LuaTable):
							lua_table.set_field(lua_var, index.get_value())
					else:
						if isinstance(lua_table, LuaTable):
							lua_table.set_field(LuaVariable(index.get_value()), index.get_value())
				elif isinstance(var, MemberExpression):
					lua_table = self.node_visitor(var.base)
					index = str(var.identifier)
					if i < variable_types_count:
						if isinstance(lua_table, LuaTable):
							lua_table.set_field(self.get_lua_variable(variable_types[i], index), index)
					elif i < initial_values_count:
						lua_var = initial_values[i]
						lua_var._name = index
						if isinstance(lua_table, LuaTable):
							lua_table.set_field(lua_var, index)
					else:
						if isinstance(lua_table, LuaTable):
							lua_table.set_field(LuaVariable(index), index)
				else:
					SharedFunctions.debug_print("Unknown var type in parse_assignment_or_call_statement", var, type(var), str(var))
				i += 1
			# Add variables to scope
			for var in final_variables:
				self.push_to_scope(var, False)
			return AssignmentStatement(final_variables, initial_values)
		if not expression:
			self.raise_error(ParsingError, "Expected a call statement")
		self.node_visitor(expression)
		return CallStatement(expression)

	#@timed
	def parse_identifier(self, a_in_expression = False):
		if self.peek(TokenEnum.NAME, 0):
			identifier = self.tokens_to_process[0].value
			self.next()
			return Identifier(identifier)
		if a_in_expression:
			return None
		self.raise_error(ParsingError, "Expected a name")

	#@timed
	def parse_expression(self):
		expression = self.parse_sub_expression(0)
		self.node_visitor(expression)
		return expression

	#@timed
	def parse_expected_expression(self):
		expression = self.parse_expression()
		if not expression:
			self.raise_error(ExpectedExpressionError, "Expected an expression")
		else:
			return expression

	#@timed
	def parse_sub_expression(self, a_min_precedence):
		operator_type = self.tokens_to_process[0].type
		expression = None
		if self.is_unary_op(operator_type):
			self.next()
			argument = self.parse_sub_expression(10)
			if not argument:
				self.raise_error(ExpectedExpressionError, "Expected a sub-expression")
			expression = UnaryExpression(operator_type, argument)
		if not expression:
			expression = self.parse_primary_expression()
			if not expression:
				expression = self.parse_prefix_expression()
		if not expression:
			return None

		while True:
			operator_type = self.tokens_to_process[0].type
			precedence = self.binary_precedence(operator_type)
			if precedence == 0 or precedence <= a_min_precedence:
				break
			if operator_type == TokenEnum.OP_POW or operator_type == TokenEnum.OP_CONCAT:
				precedence -= 1
			self.next()
			right = self.parse_sub_expression(precedence)
			if not right:
				self.raise_error(ExpectedExpressionError, "Expected a sub-expression")
			expression = BinaryExpression(operator_type, expression, right)
		return expression

	#@timed
	def is_unary_op(self, a_type):
		return {
			TokenEnum.OP_LEN: True,
			TokenEnum.OP_SUB: True,
			TokenEnum.OP_BIT_NOT_XOR: True,
			TokenEnum.KW_NOT: True
		}.get(a_type, False)

	#@timed
	def binary_precedence(self, a_type):
		return {
			TokenEnum.OP_POW: 12,
			TokenEnum.OP_MUL: 10,
			TokenEnum.OP_MOD: 10,
			TokenEnum.OP_DIV: 10,
			TokenEnum.OP_IDIV: 10,
			TokenEnum.OP_ADD: 9,
			TokenEnum.OP_SUB: 9,
			TokenEnum.OP_CONCAT: 8,
			TokenEnum.OP_BIT_RSHIFT: 7,
			TokenEnum.OP_BIT_LSHIFT: 7,
			TokenEnum.OP_BIT_AND: 6,
			TokenEnum.OP_BIT_NOT_XOR: 5,
			TokenEnum.OP_BIT_OR: 4,
			TokenEnum.OP_GREATER: 3,
			TokenEnum.OP_LESS: 3,
			TokenEnum.OP_GREATER_THAN_OR_EQUAL: 3,
			TokenEnum.OP_LESS_THAN_OR_EQUAL: 3,
			TokenEnum.OP_NOT_EQUAL: 3,
			TokenEnum.OP_EQUAL: 3,
			TokenEnum.KW_AND: 2,
			TokenEnum.KW_OR: 1
		}.get(a_type, 0)

	#@timed
	def parse_prefix_expression(self):
		base = None
		if self.peek(TokenEnum.NAME, 0): # Prefix
			base = self.parse_identifier()
		elif self.consume(TokenEnum.LEFT_PARENTHESIS):
			if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
				base = self.parse_expected_expression()
				self.expect(TokenEnum.RIGHT_PARENTHESIS)
		else:
			return None
		while True: # Suffix
			if self.consume(TokenEnum.LEFT_BRACKET):
				expression = self.parse_expected_expression()
				base = IndexExpression(base, expression)
				self.expect(TokenEnum.RIGHT_BRACKET)
			elif self.consume(TokenEnum.DOT):
				identifier = self.parse_identifier(True)
				if not identifier:
					self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=[base,
							TokenEnum.DOT])
				base = MemberExpression(base, TokenEnum.DOT, identifier)
				self.node_visitor(base)
			elif self.consume(TokenEnum.COLON):
				identifier = self.parse_identifier(True)
				if not identifier:
					self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=[base,
							TokenEnum.COLON])
				base = MemberExpression(base, TokenEnum.COLON, identifier)
				base = self.parse_call_expression(base)
				self.node_visitor(base)
			elif self.peek(TokenEnum.LEFT_PARENTHESIS, 0) or self.peek(TokenEnum.LEFT_CURLY_BRACE, 0):
				base = self.parse_call_expression(base)
			elif self.peek(TokenEnum.STRING, 0):
				base = self.parse_call_expression(base)
			else:
				return base
		return base

	#@timed
	def parse_call_expression(self, a_base):
		def expect_parameter_expression(a_expressions):
			nth_parameter = len(a_expressions)
			lua_table = self.node_visitor(a_base)
			self.raise_error(ExpectedFunctionParameterExpressionError,
				"Expected a parameter expression for a local function",
				a_additional_arguments=[lua_table, nth_parameter])

		if self.consume(TokenEnum.LEFT_PARENTHESIS):
			expressions = []
			if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
				expression = self.parse_expression()
				if not expression:
					expect_parameter_expression(expressions)
				self.node_visitor(expression)
				expressions.append(expression)
				while self.consume(TokenEnum.COMMA):
					expression = self.parse_expression()
					if not expression:
						expect_parameter_expression(expressions)
					self.node_visitor(expression)
					expressions.append(expression)
				if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
					expect_parameter_expression(expressions)
					self.expect(TokenEnum.RIGHT_PARENTHESIS)
			return CallExpression(a_base, expressions)
		elif self.consume(TokenEnum.LEFT_CURLY_BRACE):
			return TableCallExpression(a_base, self.parse_table_constructor())
		elif self.consume(TokenEnum.STRING):
			return StringCallExpression(a_base, self.parse_primary_expression())
		self.raise_error(ParsingError, "Expected a call expression")

	#@timed
	def parse_primary_expression(self):
		if self.peek(TokenEnum.STRING, 0):
			type_ = self.tokens_to_process[0].type
			value = self.tokens_to_process[0].value
			self.next()
			return Literal(type_, value)
		elif self.peek(TokenEnum.NUMBER, 0):
			type_ = self.tokens_to_process[0].type
			value = None
			try:
				value = int(self.tokens_to_process[0].value)
			except ValueError:
				value = float(self.tokens_to_process[0].value)		
			self.next()
			return Literal(type_, value)
		elif self.peek(TokenEnum.KW_TRUE, 0):
			type_ = self.tokens_to_process[0].type
			value = True
			self.next()
			return Literal(type_, value)
		elif self.peek(TokenEnum.KW_FALSE, 0):
			type_ = self.tokens_to_process[0].type
			value = False
			self.next()
			return Literal(type_, value)
		elif self.peek(TokenEnum.KW_NIL, 0):
			type_ = self.tokens_to_process[0].type
			value = None
			self.next()
			return Literal(type_, value)
		elif self.peek(TokenEnum.VARARG, 0):
			type_ = self.tokens_to_process[0].type
			value = self.tokens_to_process[0].value
			self.next()
			lua_table = LuaTable("")
			lua_table.set_field(0, "n")
			return Literal(type_, lua_table)
		elif self.consume(TokenEnum.KW_FUNCTION):
			return self.parse_function_declaration(None, False)
		elif self.consume(TokenEnum.LEFT_CURLY_BRACE):
			return self.parse_table_constructor()

	#@timed
	def parse_table_constructor(self):
		fields = []
		while True:
			if self.consume(TokenEnum.LEFT_BRACKET):
				key = self.parse_expected_expression()
				self.expect(TokenEnum.RIGHT_BRACKET)
				self.expect(TokenEnum.OP_ASSIGN)
				value = self.parse_expected_expression()
				if PYTHON_VERSION[0] >= 3 and isinstance(key, Literal) and isinstance(key.value, str):
					fields.append(TableKey(key.value, value))
				elif PYTHON_VERSION[0] == 2 and isinstance(key, Literal) and (isinstance(key.value, str) or isinstance(key.value, unicode)):
					fields.append(TableKey(key.value, value))
				else:
					fields.append(TableKey(key, value))
			elif self.peek(TokenEnum.NAME, 0):
				if self.peek(TokenEnum.OP_ASSIGN, 1):
					key = self.parse_identifier()
					self.next()
					value = self.parse_expected_expression()
					fields.append(TableKeyString(str(key), value))
				else:
					value = self.parse_expected_expression()
					fields.append(TableValue(value))
			else:
				value = self.parse_expression()
				if not value:
					break
				fields.append(TableValue(value))
			if self.peek(TokenEnum.COMMA, 0) or self.peek(TokenEnum.SEMICOLON, 0):
				self.next()
				continue
			break
		if not self.consume(TokenEnum.RIGHT_CURLY_BRACE):
			self.raise_error(ExpectedExpressionError, "Expected %s" % TOKEN_DESCRIPTION[TokenEnum.RIGHT_CURLY_BRACE])
		return TableConstructorExpression(fields)

	#@timed
	def is_arithmetic_operator(self, a_operator_type):
		return {
			TokenEnum.OP_ADD : True,
			TokenEnum.OP_DIV : True,
			TokenEnum.OP_IDIV : True,
			TokenEnum.OP_MOD : True,
			TokenEnum.OP_MUL : True,
			TokenEnum.OP_POW : True,
			TokenEnum.OP_SUB : True
		}.get(a_operator_type, False)

	#@timed
	def is_comparison_operator(self, a_operator_type):
		return {
			TokenEnum.OP_EQUAL : True,
			TokenEnum.OP_GREATER : True,
			TokenEnum.OP_GREATER_THAN_OR_EQUAL : True,
			TokenEnum.OP_LESS : True,
			TokenEnum.OP_LESS_THAN_OR_EQUAL : True,
			TokenEnum.OP_NOT_EQUAL : True,
			TokenEnum.KW_AND : True,
			TokenEnum.KW_OR : True
		}.get(a_operator_type, False)

	#@timed
	def is_bitwise_operator(self, a_operator_type):
		return {
			TokenEnum.OP_BIT_AND : True,
			TokenEnum.OP_BIT_OR : True,
			TokenEnum.OP_BIT_NOT_XOR : True,
			TokenEnum.OP_BIT_LSHIFT : True,
			TokenEnum.OP_BIT_RSHIFT : True
		}.get(a_operator_type, False)

	#@timed
	def node_visitor(self, a_node, a_previous = None, a_indent = "\t"):
		result = None
		indent_step = "\t"
#		SharedFunctions.debug_print(a_indent, "Entering", str(a_node), type(a_node), "with", str(a_previous))
		type_ = type(a_node)
		if type_ == BinaryExpression:
			lexp = self.node_visitor(a_node.left_expression, a_indent=a_indent + indent_step)
			rexp = self.node_visitor(a_node.right_expression, a_indent=a_indent + indent_step)
			if self.is_arithmetic_operator(a_node.operator_type):
				result = LuaNumber("", 0)
			elif self.is_comparison_operator(a_node.operator_type):
				result = LuaBoolean("", False)
			elif self.is_bitwise_operator(a_node.operator_type):
				result = LuaNumber("", 0)
			elif a_node.operator_type == TokenEnum.OP_CONCAT:
				result = LuaString("", "")
			else:
				self.raise_error(ParsingError, "Unsupported binary operator %s"
					% TOKEN_DESCRIPTION[a_node.operator_type])
		elif type_ == UnaryExpression:
			exp = self.node_visitor(a_node.expression, a_indent=a_indent + indent_step)
			if a_node.operator_type == TokenEnum.OP_LEN:
				result = LuaNumber("", 0)
			elif a_node.operator_type == TokenEnum.OP_SUB:
				result = exp
			elif a_node.operator_type == TokenEnum.OP_BIT_NOT_XOR:
				result = LuaNumber("", 0)
			elif a_node.operator_type == TokenEnum.KW_NOT:
				result = LuaBoolean("", False)
		elif type_ == Literal:
			if a_previous:
				if isinstance(a_previous, LuaTable):
					exists = a_previous.get_field(a_node.value)
					if exists:
						result = exists
					else:
						result = LuaNil("")
			else:
				if a_node.type == TokenEnum.NUMBER:
					result = LuaNumber("", a_node.value)
				elif a_node.type == TokenEnum.STRING:
					result = LuaString("", a_node.value)
				elif a_node.type == TokenEnum.KW_TRUE:
					result = LuaBoolean("", a_node.value)
				elif a_node.type == TokenEnum.KW_FALSE:
					result = LuaBoolean("", a_node.value)
				elif a_node.type == TokenEnum.KW_NIL:
					result = LuaNil("")
		elif type_ == MemberExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.identifier, result, a_indent=a_indent + indent_step)
			if result and a_node.operator_type == TokenEnum.COLON and not isinstance(result, LuaFunction):
				self.raise_error(ParsingError, "'%s' is not a function" % result.get_name())
		elif type_ == IndexExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.expression, result, a_indent=a_indent + indent_step)
		elif type_ == TableConstructorExpression:
			lua_table = LuaTable("")
			i = 1
			fields = []
			for field in a_node.fields:
				field_result = self.node_visitor(field)
				if isinstance(field_result, list):
					field_result = field_result[0]
				if isinstance(field, TableValue):
					field_result._name = i
					lua_table.set_field(field_result, i)
					i += 1
				elif isinstance(field, TableKey):
					field_result._name = field.key
					lua_table.set_field(field_result, field.key)
				elif isinstance(field, TableKeyString):
					field_result._name = field.key
					lua_table.set_field(field_result, field.key)
			result = lua_table
		elif type_ == TableValue:
			result = self.node_visitor(a_node.value, a_indent=a_indent + indent_step)
		elif type_ == TableKeyString:
			result = self.node_visitor(a_node.value, a_indent=a_indent + indent_step)
		elif type_ == TableKey:
			result = self.node_visitor(a_node.value, a_indent=a_indent + indent_step)
		elif type_ == StringCallExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.expression, a_indent=a_indent + indent_step)
		elif type_ == TableCallExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.table, a_indent=a_indent + indent_step)
		elif type_ == CallExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)			
			if result and isinstance(result, LuaFunction):
				return_types = result.get_return_types()
				if return_types:
					result_types = []
					for return_type in return_types:
						if PYTHON_VERSION[0] >= 3 and isinstance(return_type, str):
							if return_type == "integer" or return_type == "float":
								return_type = "number"
							result_types.append(self.get_lua_variable(return_type, ""))
						elif PYTHON_VERSION[0] == 2 and (isinstance(return_type, str) or isinstance(return_type, unicode)):
							if return_type == "integer" or return_type == "float":
								return_type = "number"
							result_types.append(self.get_lua_variable(return_type, ""))
						else:
							result_types.append(return_type)
					if result_types:
						result = result_types
				else:
					result = LuaNil("")
			if a_node.expressions: # Arguments
				for argument in a_node.expressions:
					self.node_visitor(argument, a_indent=a_indent + indent_step)
		elif type_ == Identifier:
			if a_previous:
				if isinstance(a_previous, list):
					a_previous = a_previous[0]
				if isinstance(a_previous, LuaFunction):
					return_types = a_previous.get_return_types()
					if return_types:
						a_previous = self.get_lua_variable(return_types[0], "")
				if isinstance(a_previous, LuaTable):
					exists = a_previous.get_field(str(a_node))
					if exists:
						result = exists
					else:
						result = LuaNil(str(a_node))
				elif isinstance(a_previous, LuaString):
					exists = self.standard_libraries_scope["string"].get_field(str(a_node))
					if exists:
						result = exists
					else:
						result = LuaNil(str(a_node))
			else:
				exists = self.is_variable_in_scope(str(a_node))
				if exists:
					result = exists
				else:
					self.raise_error(ParsingError, "'%s' is not a known variable" % a_node)
#		else:
#			SharedFunctions.debug_print(a_indent, "Unknown node type", type_)
#		SharedFunctions.debug_print(a_indent, "Exiting", str(a_node), type(a_node), "with", str(result))
		return result
#@timed
def get_lua_variable_completion(a_lua_variable, a_functions_as_attributes = False, a_functions_on_instance = True):
	assert isinstance(a_lua_variable, LuaVariable)
	variable_type = type(a_lua_variable)
	contents = a_lua_variable.get_name()
	if PYTHON_VERSION[0] >= 3 and not isinstance(contents, str):
		return
	elif PYTHON_VERSION[0] == 2 and not isinstance(contents, str) and not isinstance(contents, unicode):
		return
	trigger = str(a_lua_variable.get_name()).lower()
	if variable_type == LuaVariable:
#		if a_lua_variable._type:
#			return ("%s\t%s var." % (trigger, a_lua_variable._type), contents,)
#		else:
		return ("%s\t%s" % (trigger, str(a_lua_variable)), contents,)
	elif variable_type == LuaNil:
		return ("%s\tnil" % trigger, contents,)
	elif variable_type == LuaBoolean:
		return ("%s\tboolean" % trigger, contents,)
	elif variable_type == LuaNumber:
		return ("%s\tnumber" % trigger, contents,)
	elif variable_type == LuaString:
		return ("%s\tstring" % trigger, contents,)
	elif variable_type == LuaFunction:
		if a_functions_as_attributes:
			return ("%s\t%s" % (trigger, str(a_lua_variable)), contents,)
		else:
			parameters = []
			i = 1
			for param in a_lua_variable.get_parameters():
				parameters.append("${%d:%s}" % (i, param.get_name()))
				i += 1
			if not a_functions_on_instance:
				parameters.pop(0)
			return ("%s\t%s" % (trigger, str(a_lua_variable)), "%s(%s)" % (contents, ", ".join(parameters)),)
	elif variable_type == LuaTable:
		return ("%s\t%s" % (trigger, str(a_lua_variable)), contents,)
	elif variable_type == LuaThread:
		return ("%s\tthread" % trigger, contents,)
#	elif variable_type == LuaUserdata:
#		return ("%s\tuserdata" % trigger, contents,)

#@timed
def get_all_base_script_completions(a_scope_list):
	results = []
	for scope in a_scope_list[1:]:
		for key, value in scope.items():
			completion = get_lua_variable_completion(value)
			if completion:
				results.append(completion)
	for key, value in a_scope_list[0].items():
		if key == "file":
			continue
		completion = get_lua_variable_completion(value)
		if completion:
			results.append(completion)
	return results

#@timed
def get_all_type_completions(a_classes, a_enums):
	result = []
	for class_key in a_classes:
		result.append(("%s\tclass" % (class_key.lower()), class_key,))
	for enum_key in a_enums:
		result.append(("%s\tenum" % (enum_key.lower()), enum_key,))
	result.append(("%s\ttype" % ("boolean".lower()), "boolean",))
	result.append(("%s\ttype" % ("number".lower()), "number",))
	result.append(("%s\ttype" % ("string".lower()), "string",))
	result.append(("%s\ttype" % ("table".lower()), "table",))
	result.append(("%s\ttype" % ("nil".lower()), "nil",))
	return result

#@timed
def clear_linter_highlights(a_view):
	a_view.erase_regions("subliming_of_isaac_linter_errors")

#@timed
def add_linter_highlight(a_view, a_line, a_column = None):
	regions = a_view.get_regions("subliming_of_isaac_linter_errors")
	if a_column: # Highlight a word
		point = a_view.text_point(a_line-1, a_column)
		regions.append(a_view.word(sublime.Region(point)))
	else: # Highlight a line
		point = a_view.text_point(a_line-1, 1)
		regions.append(a_view.line(sublime.Region(point)))
	if len(regions) > 0:
		a_view.add_regions("subliming_of_isaac_linter_errors", regions, "invalid")

class EventListener(sublime_plugin.EventListener):
	__slots__ = [
		"parser",
		"parsing",
		"queue",
		"view",
		"scope_cache",
		"capable_of_popup"
	]
	def __init__(self):
		self.parser = Parser()
		self.parsing = False
		self.queue = 0
		self.scope_cache = {}
		self.capable_of_popup = None

	#@timed
	def scrape_api(self, a_index):
		if a_index >= 0:
			sublime.active_window().run_command("subliming_of_isaac_scrape_docs")

	#@timed
	def add_completions_flags(self, a_completions):
		return (a_completions, sublime.INHIBIT_WORD_COMPLETIONS | sublime.INHIBIT_EXPLICIT_COMPLETIONS,)

	#@timed
	def on_query_completions(self, a_view, a_prefix, a_locations):
		settings = SharedFunctions.get_package_settings()
		if (a_view.scope_name(0).split(" ")[0] in settings.get("completions_scope")
			and settings.get("context_completions", True) and settings.get("enable_linter", True)):
			if self.parsing:
				return
			elif not self.parser.afterbirth_api:
				sublime.status_message("Linter needs to complete successfully before completions can be given")
				return
			self.parsing = True
			start_time = time.time()

			def exit():
#				SharedFunctions.debug_print("Finished completing in %f milliseconds."
#					% ((time.time() - start_time)*1000))
				self.parsing = False

			completions = []
			identifier = self.view.buffer_id()
			caret_point = a_view.sel()[0].begin()
			caret_line, caret_column = a_view.rowcol(caret_point)
			script_to_cursor = a_view.substr(sublime.Region(a_view.line(caret_point).begin(), caret_point))
			if len(a_prefix) > 0:
				script_to_cursor = script_to_cursor[:-len(a_prefix)]
			last_char = None
			if len(script_to_cursor) > 0:
				last_char = script_to_cursor[-1]
			self.invalidate_scope_cache(caret_line, identifier)
			scopes = self.get_scope(caret_line, identifier)
			if scopes:
				scopes = scopes.scope
			try: # Successful parsing
				line = [a for a in self.parser.parse(script_to_cursor, caret_line, scopes, True)]
				if not line:
					# Functions, namespaces, variables, parameters
					completions = get_all_base_script_completions(self.parser.scope)
			except LexingError as error:
				if PYTHON_VERSION[0] >= 3: #TODO Remove?
					sublime.status_message("Lexing error on line %d, column %d: %s"
						% (error.line, error.column, error.message))
			except ExpectedNameError as error:
				try:
					expression_result = self.parser.node_visitor(error.base)
					if not expression_result:
						completions = get_all_base_script_completions(self.parser.scope)
					else:
						type_ = type(expression_result)
						if type_ == list and expression_result:
							expression_result = expression_result[0]
							type_ = type(expression_result)
						if error.preceding_operator_type == TokenEnum.DOT:
							if type_ == LuaTable:
								for field_key, field in expression_result.get_fields():
									completion = get_lua_variable_completion(field)
									if completion:
										completions.append(completion)
							elif type_ == LuaString:
								if expression_result.get_name() != "string":
									string_class = self.parser.scope[0].get("string", None)
									if string_class:
										for field_key, field in string_class.get_fields():
											completion = get_lua_variable_completion(field,
												a_functions_as_attributes=True)
											if completion:
												completions.append(completion)
						elif error.preceding_operator_type == TokenEnum.COLON:
							if type_ == LuaTable:
								for field_key, field in expression_result.get_fields():
									if isinstance(field, LuaFunction):
										completion = get_lua_variable_completion(field)
										if completion:
											completions.append(completion)
							elif type_ == LuaString:
								if expression_result.get_name() != "string":
									string_class = self.parser.scope[0].get("string", None)
									if string_class:
										for field_key, field in string_class.get_fields():
											completion = get_lua_variable_completion(field,
												a_functions_on_instance=False)
											if completion:
												completions.append(completion)
				except ParsingError:
					completions = get_all_base_script_completions(self.parser.scope)
			except ExpectedPreprocessorTypeArgumentError as error:
				completions = get_all_type_completions(self.parser.api_classes, self.parser.api_enums)
			except ExpectedFunctionParameterExpressionError as error:
				completions = get_all_base_script_completions(self.parser.scope)
#				SharedFunctions.debug_print(error.function, error.nth_parameter)
				if self.capable_of_popup:
					# Show popup here
					if error.function and isinstance(error.function, LuaFunction):
						function_parameters = []
						function_docstring = error.function.get_description()
						if self.parser.api_classes.get(error.function.get_name(), None):
							if function_docstring != "":
								function_docstring = ("%s class constructor\n\n%s"
									% (error.function.get_name(), function_docstring))
							else:
								function_docstring = ("%s class constructor"
									% error.function.get_name())
						parameters = error.function.get_parameters()
						if parameters:
							i = 0
							for param in parameters:
								parameter_name = param.get_name()
								if parameter_name == "...":
									if i == error.nth_parameter:
										function_parameters.append("<b>vararg ...</b>")
									else:
										function_parameters.append("vararg ...")
								else:
									parameter_type = str(param)
									
									if parameter_name == "":
										parameter_name = "param%d" % (i+1)
									if i == error.nth_parameter:
										function_parameters.append(("<b>%s %s</b>"
											% (parameter_type, parameter_name)).strip())
									else:
										function_parameters.append(("%s %s"
											% (parameter_type, parameter_name)).strip())
								i += 1
						css = """<style>
html {
background-color: %s;
}
body {
font-size: %spx;
color: %s;
}
b {
color: %s;
}
h1 {
font-size: %spx;
color: %s;
}
</style>""" % (settings.get("popup_background_color", "#393939"),
				settings.get("popup_body_font_size", 12),
				settings.get("popup_body_font_color", "#747369"),
				settings.get("popup_bold_color", "#ffffff"),
				settings.get("popup_heading_font_color", 14),
				settings.get("popup_heading_font_size", "#bfbfbf"))
						
						content = ""
						if function_parameters:
							content = "Parameters:\n %s" % ("\n ".join(function_parameters))
						if function_docstring:
							function_docstring = cgi.escape(function_docstring)
							if content:
								content = "%s\n\n%s" % (content, function_docstring)
							else:
								content = "%s" % function_docstring
						if content != "":
							content = content.replace("\n", "<br>")
							content = "%s%s" % (css, content)
							if a_view.is_popup_visible():
								a_view.update_popup(content)
							else:
								a_view.show_popup(content,
									flags=sublime.COOPERATE_WITH_AUTO_COMPLETE,
									max_width=settings.get("popup_max_width", 600), #TODO Implement setting?
									max_height=settings.get("popup_max_height", 300)) #TODO Implement setting?
			except ExpectedExpressionError as error:
				completions = get_all_base_script_completions(self.parser.scope)
			except ParsingError as error:
				if PYTHON_VERSION[0] >= 3: #TODO Remove?
					sublime.status_message("Parsing error when completing: %s" % error.message)
			exit()
			uniques = {}
			for comp in completions:
				uniques[comp[0]] = comp
			completions = []
			for key, value in uniques.items():
				completions.append(value)
			return self.add_completions_flags(completions)

	#@timed
	def on_modified(self, a_view):
		settings = SharedFunctions.get_package_settings()
		if (a_view.scope_name(0).split(" ")[0] in settings.get("completions_scope")
			and settings.get("enable_linter", True)):
			clear_linter_highlights(a_view)
			self.view = a_view
			self.identifier = a_view.buffer_id()
			self.source_string = a_view.substr(sublime.Region(0, a_view.size()))
			self.queue += 1
			delay = settings.get("linter_delay", 0.5)
			if delay < 0.25:
				delay = 0.25
			thread = threading.Timer(delay, self.lint)
			thread.daemon = True
			thread.start()

	#@timed
	def on_post_save(self, a_view):
		settings = SharedFunctions.get_package_settings()
		if (a_view.scope_name(0).split(" ")[0] in settings.get("completions_scope")
			and settings.get("enable_linter", True)):
			clear_linter_highlights(a_view)
			self.view = a_view
			self.identifier = a_view.buffer_id()
			self.source_string = a_view.substr(sublime.Region(0, a_view.size()))
			self.queue += 1
			self.lint(True)

	#@timed
	def invalidate_scope_cache(self, a_line_index, a_identifier):
		a_line_index += 1
		cache = self.scope_cache.get(a_identifier, None)
		if not cache:
			self.scope_cache[a_identifier] = []
			return
		if a_line_index <= 0: # Invalidation of the entire cache
			self.scope_cache[a_identifier] = []
			return
		else: # Partial invalidation of the cache
			i = 0
			while i < len(cache):
				#print("Evaluating %s against:" % a_line_index, cache[i])
				if cache[i].starts >= a_line_index:
					self.scope_cache[a_identifier] = cache[:i]
					#print("Remaining:", self.scope_cache[a_identifier])
					return
				i += 1
		#print("Failed to invalidate anything")
		return

	#@timed
	def get_scope(self, a_line, a_identifier):
		cache = self.scope_cache.get(a_identifier, None)
		#print("Retrieving from:", cache)
		if not cache:
			return None
		return cache[-1]#.scope

	#@timed
	def push_scope_cache(self, a_scopes, a_identifier):
		if not a_scopes:
			return
		self.scope_cache[a_identifier].extend(a_scopes)
		#print("Pushed to:", self.scope_cache[a_identifier])

	#@timed
	def get_source_to_lint(self, a_line_index, a_identifier):
		starting_line_index = a_line_index
		if self.scope_cache[a_identifier]:
			starting_line_index = self.scope_cache[a_identifier][-1][0]
		else:
			starting_line_index = 0
		start_point = self.view.text_point(starting_line_index, 0)
		return self.view.substr(sublime.Region(start_point, self.view.size())), starting_line_index

	#@timed
	def lint(self, a_on_save = False):
		self.queue -= 1
		if self.queue > 0:
			return
		if self.parsing:
			return
		if self.capable_of_popup == None:
			self.capable_of_popup = int(sublime.version()) >= 3080
		if int(sublime.version()) >= 3103 and self.view.is_auto_complete_visible():
			return
		self.parsing = True
		start_time = time.time()
#		SharedFunctions.debug_print("")

		def exit():
			self.parsing = False

		scopes_to_cache = []
		source_to_store = self.source_string
		try:
			for line in self.parser.parse(self.source_string):#, 0)#, None):#scope):
				if line:
					scopes_to_cache.append(line)
		except LexingError as error:
			if PYTHON_VERSION[0] >= 3 or a_on_save:
				sublime.status_message("Lexing error on line %d, column %d: %s" % (error.line, error.column,
					error.message))
				settings = SharedFunctions.get_package_settings()
				if settings.get("highlight_linter_errors", True):
					add_linter_highlight(self.view, error.line, error.column)
				if a_on_save and settings.get("show_linter_errors_on_save", True):
					error_list = [error.message, "Line %d, column %d" % (error.line, error.column)]
					self.view.window().show_quick_panel([error_list], self.error_choice)
			return exit()
		except ParsingError as error:
			if PYTHON_VERSION[0] >= 3 or a_on_save:
				sublime.status_message("Parsing error on line %d, column %d: %s"
					% (error.line, error.column, error.message))
				settings = SharedFunctions.get_package_settings()
				if settings.get("highlight_linter_errors", True):
					add_linter_highlight(self.view, error.line)
				if a_on_save and settings.get("show_linter_errors_on_save", True):
					error_list = [error.message, "Line %d, column %d" % (error.line, error.column)]
					self.view.window().show_quick_panel([error_list], self.error_choice)
			return exit()
		self.invalidate_scope_cache(0, self.identifier)
		if scopes_to_cache:
			self.push_scope_cache(scopes_to_cache, self.identifier)
		if PYTHON_VERSION[0] >= 3 or a_on_save:
			sublime.status_message("Finished linting in %.0f ms" % ((time.time() - start_time)*1000))
			clear_linter_highlights(self.view)
		self.parsing = False

	#@timed
	def error_choice(self, a_index):
		pass