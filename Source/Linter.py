"""
This module implements linting and context-sensitive completions. The parser is based on
luaparse (https://github.com/oxyc/luaparse), which is a Lua parser implemented in Javascript, but modified
to implement certain additional checks and custom exceptions that are used to implement context-sensitive
completions. luaparse's license is included in the 'luaparse-LICENSE' file.
"""
import sublime, sublime_plugin, os, sys, json, re, copy, time, threading
PYTHON_VERSION = sys.version_info
if PYTHON_VERSION[0] == 2:
	import imp
	scraper_module = os.path.join(os.getcwd(), "Scraper.py")
	imp.load_source("Scraper", scraper_module)
	del scraper_module
	shared_enums_module = os.path.join(os.getcwd(), "SharedEnums.py")
	imp.load_source("SharedEnums", shared_enums_module)
	del shared_enums_module
	shared_functions_module = os.path.join(os.getcwd(), "SharedFunctions.py")
	imp.load_source("SharedFunctions", shared_functions_module)
	del shared_functions_module
	import Scraper
	from SharedEnums import APIKeyEnum
	from SharedEnums import CompletionKeyEnum
	import SharedFunctions
elif PYTHON_VERSION[0] >= 3:
	from . import Scraper
	from .SharedEnums import CompletionKeyEnum
	from .SharedEnums import APIKeyEnum
	from . import SharedFunctions

# This is left here in case it is ever necessary to look at the execution time of specific functions.
#from functools import wraps
#
#def timed(f):
#	@wraps(f)
#	def wrapper(*args, **kwds):
#		start = time.time()
#		result = f(*args, **kwds)
#		elapsed = time.time() - start
#		SharedFunctions.print("%s took %f time to finish" % (f.__name__, elapsed*1000))
#		return result
#	return wrapper

class PreprocessorCommandEnum(object):
	"""
	Enum for special commands implemented as:

		--@COMMAND{;COMMAND}

	Currently the only supported command is for type annotations:

		Variable and parameter type annotation ::= [variable_type{, variable_type}]

		Function return type annotation ::= [-> function_return_type]

		Combined type annotations ::= variable_type{, variable_type} -> function_return_type

	{} = 0 or more times
	[] = optional
	"""
	RETURN_TYPE = "RETURN_TYPE" # Used to specify the type returned by a function
	VARIABLE_TYPES = "VARIABLE_TYPES" # Used to specify the types of variables in any variable declaration

class ScopeObjectEnum(object):
	"""
	Enum for keys used in dictionaries generated specifically for the scope list.
	"""
	IS_CLASS = "Is class"
	IS_ENUM = "Is enum"
	IS_FUNCTION = "Is function"
	IS_NAMESPACE = "Is namespace"
	IS_PARAMETER = "Is parameter"
	IS_VARIABLE = "Is variable"
	IS_CONSTRUCTOR = "Is constructor"
	PARAMETERS = "Parameters"
	TYPE = "Type"
	RETURNS = "Returns"
	NAME = "Name"
	FUNCTIONS = "Functions"
	ATTRIBUTES = "Attributes"
	MEMBERS = "Members"

class TokenEnum(object):
	"""
	Enum for tokens generated by the lexer.
	"""
	COLON = 0
	COMMA = 1
	DOT = 2
	DOUBLE_COLON = 3
	KW_AND = 4
	KW_BREAK = 5
	KW_DO = 6
	KW_ELSE = 7
	KW_ELSEIF = 8
	KW_END = 9
	KW_FALSE = 10
	KW_FOR = 11
	KW_FUNCTION = 12
	KW_GOTO = 13
	KW_IF = 14
	KW_IN = 15
	KW_LOCAL = 16
	KW_NIL = 17
	KW_NOT = 18
	KW_OR = 19
	KW_REPEAT = 20
	KW_RETURN = 21
	KW_THEN = 22
	KW_TRUE = 23
	KW_UNTIL = 24
	KW_WHILE = 25
	LEFT_BRACKET = 26
	LEFT_CURLY_BRACE = 27
	LEFT_PARENTHESIS = 28
	NAME = 29
	NUMBER = 30
	OP_ADD = 31
	OP_ASSIGN = 32
	OP_BIT_AND = 33
	OP_BIT_LSHIFT = 34
	OP_BIT_NOT_XOR = 35
	OP_BIT_OR = 36
	OP_BIT_RSHIFT = 37
	OP_CONCAT = 38
	OP_DIV = 39
	OP_EQUAL = 40
	OP_GREATER = 41
	OP_GREATER_THAN_OR_EQUAL = 42
	OP_IDIV = 43
	OP_LEN = 44
	OP_LESS = 45
	OP_LESS_THAN_OR_EQUAL = 46
	OP_MOD = 47
	OP_MUL = 48
	OP_NOT_EQUAL = 49
	OP_POW = 50
	OP_SUB = 51
	RIGHT_BRACKET = 52
	RIGHT_CURLY_BRACE = 53
	RIGHT_PARENTHESIS = 54
	SEMICOLON = 55
	STRING = 56
	VARARG = 57
	NEWLINE = 58
	UNMATCHED = 59
	EOF = 60
	LINE_COMMENT = 61
	BLOCK_COMMENT = 62
	WHITESPACE = 63
	PREPROCESSOR_COMMAND = 64

# User-friendly description of token. Values are used in error messages.
TOKEN_DESCRIPTION = [
	"colon",
	"comma",
	"dot",
	"double colon",
	"keyword 'and'",
	"keyword 'break'",
	"keyword 'do'",
	"keyword 'else'",
	"keyword 'elseif'",
	"keyword 'end'",
	"keyword 'false'",
	"keyword 'for'",
	"keyword 'function'",
	"keyword 'goto'",
	"keyword 'if'",
	"keyword 'in'",
	"keyword 'local'",
	"keyword 'nil'",
	"keyword 'not'",
	"keyword 'or'",
	"keyword 'repeat'",
	"keyword 'return'",
	"keyword 'then'",
	"keyword 'true'",
	"keyword 'until'",
	"keyword 'while'",
	"left bracket",
	"left curly brace",
	"left parenthesis",
	"name",
	"number literal",
	"addition operator",
	"assignment operator",
	"bitwise and operator",
	"bitwise left shift operator",
	"bitwise unary not/binary xor operator",
	"bitwise or operator",
	"bitwise right shift operator",
	"concatenation operator",
	"division operator",
	"equals comparison operator",
	"greater than comparison operator",
	"greater than or equal comparison operator",
	"floor division operator",
	"length operator",
	"less than comparison operator",
	"less than or equals comparison operator",
	"modulus operator",
	"multiplication operator",
	"not equals comparison operator",
	"power operator",
	"subtraction operator",
	"right bracket",
	"right curly brace",
	"right parenthesis",
	"semicolon",
	"string literal",
	"vararg operator",
	"newline",
	"unmatched",
	"end of file",
	"short comment",
	"long comment",
	"whitespace",
	"preprocessor command"
]

class Token(object):
	"""
	Object generated by the lexer.
	"""
	__slots__ = [
		"type", # TokenEnum
		"line", # str
		"column", # int
		"value" # int
	]
	def __init__(self, aType, aValue, aLine, aColumn):
		self.type = aType
		self.line = aLine
		self.column = aColumn
		self.value = aValue

	def __str__(self):
		return """
===== Token =====
Type: %s
Value: '%s'
Line: %d
Column: %d
""" % (TOKEN_DESCRIPTION[self.type], self.value, self.line, self.column)

class PreprocessorCommand(object):
	"""
	Object generated when the lexer encounters a preprocessor command.
	Used to implement e.g. type annotations.
	"""
	def __init__(self, a_command, a_arguments):
		self.command = a_command #PreprocessorCommandEnum
		self.arguments = a_arguments

# Statement objects generated by the parser.
class ElseStatement(object):
	def __init__(self):
		pass

class RepeatStatement(object):
	def __init__(self):
		pass

class BreakStatement(object):
	def __init__(self):
		pass

class DoStatement(object):
	def __init__(self):
		pass

class EndStatement(object):
	def __init__(self):
		pass

class UntilStatement(object):
	def __init__(self):
		pass

class IfStatement(object):
	def __init__(self, a_condition):
		self.condition = a_condition

class ElseIfStatement(object):
	def __init__(self, a_condition):
		self.condition = a_condition

class ReturnStatement(object):
	def __init__(self, a_expressions):
		self.expressions = a_expressions

class WhileStatement(object):
	def __init__(self, a_condition):
		self.condition = a_condition

class ForNumericStatement(object):
	def __init__(self, a_variable, a_start, a_end, a_step):
		self.variable = a_variable

class ForGenericStatement(object):
	def __init__(self, a_variables, a_iterators):
		self.variables = a_variables

class GotoStatement(object):
	def __init__(self, a_name):
		self.name = a_name

class LabelStatement(object):
	def __init__(self, a_name):
		self.name = a_name

class AssignmentStatement(object):
	def __init__(self, a_variables, a_initial_values):
		self.variables = a_variables
		self.initial_values = a_initial_values

class CallStatement(object):
	def __init__(self, a_expression):
		self.expression = a_expression

class CallExpression(object):
	def __init__(self, a_base, a_expressions):
		self.base = a_base
		self.expressions = a_expressions

class TableCallExpression(object):
	def __init__(self, a_base, a_table):
		self.base = a_base
		self.table = a_table

class StringCallExpression(object):
	def __init__(self, a_base, a_expression):
		self.base = a_base
		self.expression = a_expression

class TableKey(object):
	def __init__(self, a_key, a_value):
		self.key = a_key
		self.value = a_value

class TableKeyString(object):
	def __init__(self, a_key, a_value):
		self.key = a_key
		self.value = a_value

class TableValue(object):
	def __init__(self, a_value):
		self.value = a_value

class TableConstructorExpression(object):
	def __init__(self, a_fields):
		self.fields = a_fields

class LocalVariables(object):
	def __init__(self, a_variables, a_initial_values):
		self.variables = a_variables
		self.initial_values = a_initial_values

class IndexExpression(object):
	def __init__(self, a_base, a_expression):
		self.base = a_base
		self.expression = a_expression

class MemberExpression(object):
	def __init__(self, a_base, a_operator_type, a_identifier):
		self.operator_type = a_operator_type
		self.base = a_base
		self.identifier = a_identifier

	def __str__(self):
		if self.operator_type == TokenEnum.DOT:
			return "%s.%s" % (self.base, self.identifier)
		elif self.operator_type == TokenEnum.COLON:
			return "%s:%s" % (self.base, self.identifier)

class Literal(object):
	def __init__(self, a_type, a_value):
		self.type = a_type
		self.value = a_value

class Identifier(object):
	def __init__(self, a_value):
		self.value = a_value

	def __str__(self):
		return self.value

class FunctionSignature(object):
	def __init__(self, a_name, a_parameters, a_is_local):
		self.name = a_name
		self.parameters = a_parameters

class UnaryExpression(object):
	def __init__(self, a_operator_type, a_argument):
		self.operator_type = a_operator_type
		self.expression = a_argument

class BinaryExpression(object):
	def __init__(self, a_operator_type, a_expression, a_right):
		self.operator_type = a_operator_type
		self.left_expression = a_expression
		self.right_expression = a_right

class NodeResult(object):
	"""
	Object used by the node_visitor function to pass information while recursively walking through an AST's
	nodes.
	"""
	def __init__(self, a_type, a_calling_function):
		self.type = a_type
		self.calling_function = a_calling_function

	def __str__(self):
		return str(self.type)

# Custom exceptions raised by the lexer and parser.
class LexingError(Exception):
	def __init__(self, a_message, a_line, a_column, a_character):
		self.message = a_message
		self.line = a_line
		self.column = a_column
		self.character = a_character

class ParsingError(Exception):
	def __init__(self, a_message, a_line, a_column):
		self.message = a_message
		self.line = a_line
		self.column = a_column

class ExpectedFunctionParameterExpressionError(ParsingError):
	def __init__(self, a_message, a_line, a_column, a_function, a_nth_parameter):
		super(ParsingError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column
		self.function = a_function
		self.nth_parameter = a_nth_parameter

class ExpectedExpressionError(ParsingError):
	def __init__(self, a_message, a_line, a_column):
		super(ParsingError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column

class ExpectedNameError(ParsingError):
	def __init__(self, a_message, a_line, a_column, a_base, a_preceding_operator_type):
		super(ParsingError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column
		self.base = a_base
		self.preceding_operator_type = a_preceding_operator_type

class ExpectedPreprocessorTypeArgumentError(ParsingError):
	def __init__(self, a_message, a_line, a_column):
		super(ParsingError, self).__init__(a_message, a_line, a_column)
		self.message = a_message
		self.line = a_line
		self.column = a_column

class Parser(object):
	__slots__ = [
		"afterbirth_api",
		"token_regex",
		"keyword_regex",
		"preprocessor_command_type_annotation_regex",
		"tokens_to_process", # List of tokens waiting to be consumed by the parser
		"processed_tokens", # List of tokens that have been consumed by the parser
		"scope", # List of dicts
		"base_api_scope" # Dict
	]
	def __init__(self):
		# Regex patterns used to generate tokens.
		token_specifications = [
			(TokenEnum.PREPROCESSOR_COMMAND, r"\-\-\@[^\n\r]*"), # Specific to this parser. Not a part of the Lua language specification!
			(TokenEnum.BLOCK_COMMENT, r"\-\-\[\[[^\]]*\-\-\]\][^\n\r]*"),
			(TokenEnum.LINE_COMMENT, r"\-\-[^\n\r]*"),
			(TokenEnum.NAME, r"[_a-zA-Z][_a-zA-Z0-9]*"),
			(TokenEnum.DOUBLE_COLON, r"::"),
			(TokenEnum.COLON, r":"),
			(TokenEnum.COMMA, r","),
			(TokenEnum.LEFT_BRACKET, r"\["),
			(TokenEnum.LEFT_CURLY_BRACE, r"\{"),
			(TokenEnum.LEFT_PARENTHESIS, r"\("),
			(TokenEnum.RIGHT_BRACKET, r"\]"),
			(TokenEnum.RIGHT_CURLY_BRACE, r"\}"),
			(TokenEnum.RIGHT_PARENTHESIS, r"\)"),
			(TokenEnum.OP_ADD, r"\+"),
			(TokenEnum.OP_BIT_AND, r"&"),
			(TokenEnum.OP_BIT_LSHIFT, r"<<"),
			(TokenEnum.OP_LESS_THAN_OR_EQUAL, r"<="),
			(TokenEnum.OP_LESS, r"<"),
			(TokenEnum.OP_BIT_OR, r"\|"),
			(TokenEnum.OP_BIT_RSHIFT, r">>"),
			(TokenEnum.OP_GREATER_THAN_OR_EQUAL, r">="),
			(TokenEnum.OP_GREATER, r">"),
			(TokenEnum.OP_EQUAL, r"=="),
			(TokenEnum.OP_NOT_EQUAL, r"~="),
			(TokenEnum.OP_BIT_NOT_XOR, r"~"),
			(TokenEnum.OP_ASSIGN, r"="),
			(TokenEnum.OP_IDIV, r"//"),
			(TokenEnum.OP_DIV, r"/"),
			(TokenEnum.OP_LEN, r"#"),
			(TokenEnum.OP_MOD, r"\%"),
			(TokenEnum.OP_MUL, r"\*"),
			(TokenEnum.OP_POW, r"\^"),
			(TokenEnum.OP_SUB, r"\-"),
			(TokenEnum.SEMICOLON, r";"),
			(TokenEnum.VARARG, r"\.\.\."),
			(TokenEnum.OP_CONCAT, r"\.\."),
			(TokenEnum.DOT, r"\."),
			(TokenEnum.NEWLINE, r"[\n\r]"),
			(TokenEnum.WHITESPACE, r"[ \t]"),
			(TokenEnum.STRING, r"(?:(?<!\\)\'.*?(?:(?:\\\\\')|(?<!\\)\'))|(?:(?<!\\)\".*?(?:(?:\\\\\")|(?<!\\)\"))"),
			(TokenEnum.NUMBER, r"0[xX][0-9a-fA-F]+[pP][+-]?[0-9]+|0[xX]\.[0-9a-fA-F]+(?:[pP][+-]?[0-9]+)?|0[xX][0-9a-fA-F]+(?:\.[0-9a-fA-F]*(?:[pP][+-]?[0-9]+)?)?|[0-9]+(?:[eE][+-]?[0-9]+)|\.[0-9]+(?:[eE][+-]?[0-9]+)?|[0-9]+(?:\.[0-9]*(?:[eE][+-]?[0-9]+)?)?"),
			(TokenEnum.UNMATCHED, r"."),
		]
		self.token_regex = re.compile("|".join("(?P<t%s>%s)" % pair for pair in token_specifications))

		# Regex patterns used to match Lua keywords when a TokenEnum.NAME token has been generated.
		keyword_specifications = [
			(TokenEnum.KW_AND, r"and"),
			(TokenEnum.KW_BREAK, r"break"),
			(TokenEnum.KW_DO, r"do"),
			(TokenEnum.KW_ELSEIF, r"elseif"),
			(TokenEnum.KW_ELSE, r"else"),
			(TokenEnum.KW_END, r"end"),
			(TokenEnum.KW_FALSE, r"false"),
			(TokenEnum.KW_FOR, r"for"),
			(TokenEnum.KW_FUNCTION, r"function"),
			(TokenEnum.KW_GOTO, r"goto"),
			(TokenEnum.KW_IF, r"if"),
			(TokenEnum.KW_IN, r"in"),
			(TokenEnum.KW_LOCAL, r"local"),
			(TokenEnum.KW_NIL, r"nil"),
			(TokenEnum.KW_NOT, r"not"),
			(TokenEnum.KW_OR, r"or"),
			(TokenEnum.KW_REPEAT, r"repeat"),
			(TokenEnum.KW_RETURN, r"return"),
			(TokenEnum.KW_THEN, r"then"),
			(TokenEnum.KW_TRUE, r"true"),
			(TokenEnum.KW_UNTIL, r"until"),
			(TokenEnum.KW_WHILE, r"while"),
		]
		self.keyword_regex = re.compile("|".join("(?P<t%s>^%s$)" % pair for pair in keyword_specifications))

		# Regex pattern used to match type annotation preprocessor commands.
		self.preprocessor_command_type_annotation_regex = re.compile(
			"^(?:(?P<variable_types>[_a-zA-Z0-9, \t]+))?(?:\s*\-\>\s*(?P<return_type>[_a-zA-Z][_a-zA-Z0-9]*))?",
			re.MULTILINE)

		# JSON-compatible object containing information scraped from the Afterbirth+ API.
		self.afterbirth_api = None

		# The base scope that is generated once from the information in self.afterbirth_api
		self.base_api_scope = None

	#@timed
	def preprocessor_commands(self, a_command_string, a_line, a_column):
		a_command_string = a_command_string.strip()
		if a_command_string == "":
			raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line, a_column)
		elif a_command_string == "->":
			raise ExpectedPreprocessorTypeArgumentError("Expected a return type annotation", a_line, a_column)
		command_match = self.preprocessor_command_type_annotation_regex.match(a_command_string)
		if command_match:
			variable_types = command_match.group("variable_types")
			if variable_types:
				arguments = [type_.strip() for type_ in variable_types.split(",")]
				for arg in arguments:
					if arg == "":
						raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line,
							a_column)
				yield PreprocessorCommand(PreprocessorCommandEnum.VARIABLE_TYPES, arguments)
			return_type = command_match.group("return_type")
			if return_type:
				yield PreprocessorCommand(PreprocessorCommandEnum.RETURN_TYPE, return_type)
			elif "->" in a_command_string:
				raise ExpectedPreprocessorTypeArgumentError("Expected a return type annotation", a_line,
					a_column)
		else:
			raise ExpectedPreprocessorTypeArgumentError("Expected a type annotation", a_line, a_column)

	#@timed
	def tokenize(self, a_source_code, a_starting_line_index):
		line = 1 + a_starting_line_index
		column = -1
		for match in self.token_regex.finditer(a_source_code):
			type_ = match.lastgroup
			value_ = match.group(type_)
			type_ = int(match.lastgroup[1:])
			if type_ == TokenEnum.WHITESPACE:
				continue
			elif type_ == TokenEnum.NAME:
				keyword = self.keyword_regex.match(value_)
				if keyword:
					type_ = int(keyword.lastgroup[1:])
			elif type_ == TokenEnum.BLOCK_COMMENT:
				i = value_.count("\n")
				if i > 0:
					line += i
					column = match.end()-1
				continue
			elif type_ == TokenEnum.LINE_COMMENT:
				continue
			elif type_ == TokenEnum.STRING:
				value_ = value_[1:-1]
				yield Token(type_, value_, line, match.start()-column)
				i = value_.count("\n")
				if i > 0:
					line += i
					column = match.end()-1
				continue
			elif type_ == TokenEnum.NEWLINE:
				line += 1
				column = match.end()-1
			elif type_ == TokenEnum.PREPROCESSOR_COMMAND:
				value_ = value_[3:]
				for command in self.preprocessor_commands(value_, line, match.start()-column):
					yield Token(TokenEnum.PREPROCESSOR_COMMAND, command, line, match.start()-column)
				continue
			elif type_ == TokenEnum.UNMATCHED:
				raise LexingError("Encountered an unexpected character ('%s')" % value_,
					line, match.start()-column, value_)
			yield Token(type_, value_, line, match.start()-column)
		yield Token(TokenEnum.EOF, "\n", line, 1)

	#@timed
	def generate_api_scope(self):
		api = {}
		api[APIKeyEnum.FUNCTIONS] = {}
		for function_key, function in self.afterbirth_api.get(APIKeyEnum.FUNCTIONS, {}).items():
			returns = function.get(APIKeyEnum.RETURNS, None)
			if returns:
				returns = returns.get(APIKeyEnum.TYPE, "nil")
			api[APIKeyEnum.FUNCTIONS][function_key] = {ScopeObjectEnum.IS_FUNCTION: True,
				ScopeObjectEnum.TYPE: returns,
				ScopeObjectEnum.PARAMETERS: function.get(APIKeyEnum.PARAMETERS, [])}
		api[APIKeyEnum.NAMESPACES] = {}
		for namespace_key, namespace in self.afterbirth_api.get(APIKeyEnum.NAMESPACES, {}).items():
			api[APIKeyEnum.NAMESPACES][namespace_key] = {ScopeObjectEnum.IS_NAMESPACE: True,
				ScopeObjectEnum.FUNCTIONS: namespace.get(APIKeyEnum.FUNCTIONS, {})}
		api[APIKeyEnum.CLASSES] = {}
		for class_key, class_ in self.afterbirth_api.get(APIKeyEnum.CLASSES, {}).items():
			api[APIKeyEnum.CLASSES][class_key] = {ScopeObjectEnum.IS_CLASS: True,
				ScopeObjectEnum.FUNCTIONS: class_.get(APIKeyEnum.FUNCTIONS, {}),
				ScopeObjectEnum.ATTRIBUTES: class_.get(APIKeyEnum.ATTRIBUTES, {})}
			for function_key, function in class_.get(APIKeyEnum.FUNCTIONS, {}).items():
				if function.get(APIKeyEnum.IS_CONSTRUCTOR):
					api[APIKeyEnum.FUNCTIONS][function_key] = {ScopeObjectEnum.IS_FUNCTION: True,
					ScopeObjectEnum.IS_CONSTRUCTOR: True,
					ScopeObjectEnum.TYPE: class_key,
					ScopeObjectEnum.PARAMETERS: function.get(APIKeyEnum.PARAMETERS, [])}
		api[APIKeyEnum.ENUMS] = {}
		for enum_key, enum in self.afterbirth_api.get(APIKeyEnum.ENUMS, {}).items():
			api[APIKeyEnum.ENUMS][enum_key] = {ScopeObjectEnum.IS_ENUM: True,
			ScopeObjectEnum.MEMBERS: enum.get(APIKeyEnum.MEMBERS, {})}
		return api

	#@timed
	def tokenize_lines(self, a_source_code, a_starting_line_index):
		lines = []
		tokens = []
		for token in self.tokenize(a_source_code, a_starting_line_index):
			tokens.append(token)
			if token.type == TokenEnum.NEWLINE:
				if len(tokens) > 1:
					lines.append(tokens)
				tokens = []
		if len(tokens) > 1:
			lines.append(tokens)
		return lines

	#@timed
	def get_initial_scope(self, a_scope = None):
		# Scope structure:
		# 0 = API functions, namespaces, enums, and classes.
		# 1 = Global variables and functions.
		# 2 = Script scope.
		# 3 ... n = Local scopes nested within the script scope.
		if a_scope: # Use the scope that was given as 'a_scope'.
			return a_scope
		else: # Generate the initial scope
			if not self.afterbirth_api: # Load Afterbirth+ API, if that has not already been done.
				self.afterbirth_api = SharedFunctions.load_afterbirth_api()
				if not self.afterbirth_api:
					SharedFunctions.error_message("Failed to load Afterbirth+ API. May require scraping")
					return None
				self.base_api_scope = self.generate_api_scope()
			return [self.base_api_scope, {}, {}]

	#@timed
	def parse(self, a_source_code, a_starting_line_index = 0, a_scope = None, a_completing = False):
		lines = self.tokenize_lines(a_source_code, a_starting_line_index)
		self.scope = self.get_initial_scope(a_scope)
		if not lines:
			return
		line_number = 0
		for line in lines:
			start_time = time.time()
			line_number = line[0].line
			self.tokens_to_process = line
			self.processed_tokens = []
			statements = self.parse_line()
			if statements:
				yield [line_number, statements, copy.copy(self.scope)]
				# 0 = Line number.
				# 1 = List of statements.
				# 2 = Copy of self.scope after parsing this line of Lua code. Used for caching purposes.
		if not a_completing and len(self.scope) > 3:
			self.raise_error(ParsingError, "Found %d unterminated scopes" % (len(self.scope) - 3))

	#@timed
	def raise_error(self, a_error_class, a_message, a_line = None, a_column = None,
		a_additional_arguments = []):
		if self.processed_tokens:
			if a_line:
				raise a_error_class(a_message, a_line, 0, *a_additional_arguments)
			else:
				raise a_error_class(a_message, self.processed_tokens[-1].line,
					self.processed_tokens[-1].column, *a_additional_arguments)
		elif self.tokens_to_process:
			if a_line:
				raise a_error_class(a_message, a_line, 0, *a_additional_arguments)
			else:
				raise a_error_class(a_message, self.tokens_to_process[0].line,
					self.tokens_to_process[0].column, *a_additional_arguments)

	#@timed
	def next(self):
		if self.tokens_to_process:
			self.processed_tokens.append(self.tokens_to_process.pop(0))
		else:
			self.raise_error(ParsingError, "Nothing more to parse")

	#@timed
	def consume(self, a_token_type):
		if self.tokens_to_process[0].type == a_token_type:
			self.next()
			return True
		return False

	#@timed
	def peek(self, a_token_type, a_amount):
		if len(self.tokens_to_process) >= a_amount + 1:
			if self.tokens_to_process[a_amount].type == a_token_type:
				return True
		return False

	#@timed
	def expect(self, a_token_type):
		if self.tokens_to_process[0].type == a_token_type:
			self.next()
		else:
			self.raise_error(ParsingError, "Expected %s, got %s instead" % (TOKEN_DESCRIPTION[a_token_type],
				TOKEN_DESCRIPTION[self.tokens_to_process[0].type]))

	#@timed
	def push_to_scope(self, a_dict, a_is_local = False):
		name = str(a_dict[APIKeyEnum.NAME])
		if a_is_local:
			self.scope[-1][name] = a_dict
		else:
			modified = False
			for scope in reversed(self.scope):
				if scope.get(name, None):
					modified = True
					scope[name] = a_dict
					break
			if not modified:
				self.scope[1][name] = a_dict

	#@timed
	def is_function_in_scope(self, a_name):
		a_name = str(a_name)
		exists = self.is_in_scope(a_name)
		if exists:
			if exists.get(ScopeObjectEnum.IS_FUNCTION, None):
				return exists
		return None

	#@timed
	def is_variable_in_scope(self, a_name):
		a_name = str(a_name)
		a_name = str(a_name)
		exists = self.is_in_scope(a_name)
		if exists:
			if exists.get(ScopeObjectEnum.IS_VARIABLE, None):
				return exists
		return None

	#@timed
	def is_parameter_in_scope(self, a_name):
		a_name = str(a_name)
		exists = self.is_in_scope(a_name)
		if exists:
			if exists.get(ScopeObjectEnum.IS_PARAMETER, None):
				return exists
		return None

	#@timed
	def is_namespace_in_api(self, a_name):
		a_name = str(a_name)
		exists = self.scope[0][APIKeyEnum.NAMESPACES].get(a_name, None)
		if exists:
			return exists
		return None

	#@timed
	def is_namespace_function_in_api(self, a_name):
		a_name = str(a_name)
		for namespace_key, namespace in self.scope[0][APIKeyEnum.NAMESPACES].items():
			namespace_functions = namespace.get(ScopeObjectEnum.FUNCTIONS, None)
			if namespace_functions:
				function = namespace_functions.get(a_name, None)
				if function:
					return function
		return None

	#@timed
	def is_enum_in_api(self, a_name):
		a_name = str(a_name)
		exists = self.scope[0][APIKeyEnum.ENUMS].get(a_name, None)
		if exists:
			return exists
		return None

	#@timed
	def is_class_in_api(self, a_name):
		a_name = str(a_name)
		exists = self.scope[0][APIKeyEnum.CLASSES].get(a_name, None)
		if exists:
			return exists
		return None

	#@timed
	def is_function_in_api(self, a_name):
		a_name = str(a_name)
		exists = self.scope[0][APIKeyEnum.FUNCTIONS].get(a_name, None)
		if exists:
			return exists
		return None

	#@timed
	def is_in_scope(self, a_name):
		a_name = str(a_name)
		for scope in reversed(self.scope):
			existing = scope.get(a_name, None)
			if existing:
				return existing
		return None

	#@timed
	def create_scope(self):
		self.scope.append({})

	#@timed
	def destroy_scope(self):
		if len(self.scope) > 3:
			self.scope.pop()
		else:
			self.raise_error(ParsingError, "No scope to end")

	#@timed
	def parse_line(self):
		statements = []
		while (self.tokens_to_process[0].type != TokenEnum.NEWLINE
			and self.tokens_to_process[0].type != TokenEnum.EOF):
			statement = self.parse_statement()
			if statement:
				statements.append(statement)
		return statements

	#@timed
	def parse_statement(self):
		if self.consume(TokenEnum.KW_LOCAL):
			return self.parse_local_statement()
		elif self.consume(TokenEnum.KW_IF):
			self.create_scope()
			return self.parse_if_statement()
		elif self.consume(TokenEnum.KW_ELSEIF):
			self.destroy_scope()
			self.create_scope()
			return self.parse_elseif_statement()
		elif self.consume(TokenEnum.KW_ELSE):
			self.destroy_scope()
			self.create_scope()
			return ElseStatement()
		elif self.consume(TokenEnum.KW_RETURN):
			return self.parse_return_statement()
		elif self.consume(TokenEnum.KW_FUNCTION):
			name = self.parse_function_name()
			return self.parse_function_declaration(name, False)
		elif self.consume(TokenEnum.KW_WHILE):
			self.create_scope()
			return self.parse_while_statement()
		elif self.consume(TokenEnum.KW_FOR):
			self.create_scope()
			return self.parse_for_statement()
		elif self.consume(TokenEnum.KW_REPEAT):
			self.create_scope()
			return RepeatStatement()
		elif self.consume(TokenEnum.KW_BREAK):
			return BreakStatement()
		elif self.consume(TokenEnum.KW_DO):
			self.create_scope()
			return DoStatement()
		elif self.consume(TokenEnum.KW_GOTO):
			return self.parse_goto_statement()
		elif self.consume(TokenEnum.KW_END):
			self.destroy_scope()
			return EndStatement()
		elif self.consume(TokenEnum.KW_UNTIL):
			self.destroy_scope()
			return UntilStatement()
		elif self.consume(TokenEnum.DOUBLE_COLON):
			return self.parse_label_statement()
		elif self.consume(TokenEnum.SEMICOLON):
			return None
		elif self.consume(TokenEnum.PREPROCESSOR_COMMAND):
			return None
		return self.parse_assignment_or_call_statement()

	#@timed
	def parse_local_statement(self):
		if self.peek(TokenEnum.NAME, 0): # Variable(s)
			variables = []
			initial_values = []
			name = self.parse_identifier()
			variables.append(name)
			while self.consume(TokenEnum.COMMA):
				name = self.parse_identifier()
				variables.append(name)
			if self.consume(TokenEnum.OP_ASSIGN):
				initial_values.append(self.parse_expected_expression())
				while self.consume(TokenEnum.COMMA):
					initial_values.append(self.parse_expected_expression())
			# Add variables to scope
			i = 0
			initial_values_count = len(initial_values)
			while i < len(variables):
				type_ = "undefined"
				if i < initial_values_count:
					type_ = str(self.node_visitor(initial_values[i]))
				self.push_to_scope({ScopeObjectEnum.NAME: variables[i],
					ScopeObjectEnum.TYPE: type_, ScopeObjectEnum.IS_VARIABLE: True}, True)
				i += 1
			while self.consume(TokenEnum.PREPROCESSOR_COMMAND):
				value = self.processed_tokens[-1].value
				if value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
					i = 0
					arguments_count = len(value.arguments)
					while i < len(variables):
						if i < arguments_count:
							self.push_to_scope({ScopeObjectEnum.NAME: variables[i],
								ScopeObjectEnum.TYPE: value.arguments[i],
								ScopeObjectEnum.IS_VARIABLE: True}, False)
						i += 1
			return LocalVariables(variables, initial_values)
		elif self.consume(TokenEnum.KW_FUNCTION):
			name = self.parse_identifier()
			return self.parse_function_declaration(name, True)
		else:
			self.raise_error(ParsingError, "Incomplete local statement")

	#@timed
	def parse_if_statement(self):
		condition = self.parse_expected_expression()
		self.expect(TokenEnum.KW_THEN)
		return IfStatement(condition)

	#@timed
	def parse_elseif_statement(self):
		condition = self.parse_expected_expression()
		self.expect(TokenEnum.KW_THEN)
		return ElseIfStatement(condition)

	#@timed
	def parse_return_statement(self):
		expressions = []
		expression = self.parse_expression()
		if expression:
			expressions.append(expression)
		while self.consume(TokenEnum.COMMA):
			expression = self.parse_expected_expression()
			expressions.append(expression)
		return ReturnStatement(expressions)

	#@timed
	def is_base_type(self, a_type):
		return {
			"boolean": True,
			"false": True,
			"true": True,
			"nil": True,
			"string": True,
			"number": True,
			"table": True
		}.get(str(a_type), False)

	#@timed
	def parse_function_name(self):
		base = self.parse_identifier()
		current_type = None
		if not self.peek(TokenEnum.LEFT_PARENTHESIS, 0):
			current_type = self.is_variable_in_scope(base)
			if not current_type:
				self.raise_error(ParsingError, "'%s' is not a known variable" % base)
			current_type = current_type[APIKeyEnum.TYPE]
		while self.consume(TokenEnum.DOT):
			name = self.parse_identifier()
			if not name:
				self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=TokenEnum.DOT)
			if not self.is_base_type(current_type) and current_type != "undefined":
				class_ = self.is_class_in_api(current_type)
				if not class_:
					self.raise_error(ParsingError, "'%s' is not a known class" % current_type)
				attributes = class_.get(APIKeyEnum.ATTRIBUTES, {})
				attribute = attributes.get(str(name), None)
				if attribute:
					current_type = attribute[APIKeyEnum.TYPE]
				else:
					self.raise_error(ParsingError, "'%s' does not have an attribute called '%s'"
						% (current_type, name))
			base = MemberExpression(base, TokenEnum.DOT, name)
		if self.consume(TokenEnum.COLON):
			name = self.parse_identifier()
			if not name:
				self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=TokenEnum.COLON)
			if not self.is_base_type(current_type) and current_type != "undefined":
				class_ = self.is_class_in_api(current_type)
				if not class_:
					self.raise_error(ParsingError, "'%s' is not a known class" % current_type)
				functions = class_.get(APIKeyEnum.FUNCTIONS, {})
				function = functions.get(str(name), None)
				if function:
					self.raise_error(ParsingError, "'%s' already has a function called '%s'"
						% (current_type, name))
			base = MemberExpression(base, TokenEnum.COLON, name)
		return base

	#@timed
	def parse_function_declaration(self, a_name, a_is_local):
		parameters = []
		self.expect(TokenEnum.LEFT_PARENTHESIS)
		if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
			while True:
				if self.peek(TokenEnum.NAME, 0):
					parameter = self.parse_identifier()
					parameters.append(parameter)
					if self.consume(TokenEnum.COMMA):
						continue
					elif self.consume(TokenEnum.RIGHT_PARENTHESIS):
						break
				elif self.consume(TokenEnum.VARARG):
					parameters.append("...")
					self.expect(TokenEnum.RIGHT_PARENTHESIS)
					break
				else:
					self.raise_error(ParsingError, "Expected a function parameter")

		if isinstance(a_name, Identifier):
			self.push_to_scope({ScopeObjectEnum.NAME: a_name, ScopeObjectEnum.IS_FUNCTION: True,
				ScopeObjectEnum.PARAMETERS: parameters}, a_is_local)
		self.create_scope()
		for param in parameters:
			if param != "...":
				self.push_to_scope({ScopeObjectEnum.NAME: param, ScopeObjectEnum.IS_PARAMETER: True}, True)
			else:
				break

		parameter_types_command = None
		return_type_command = None
		while self.consume(TokenEnum.PREPROCESSOR_COMMAND):
			value = self.processed_tokens[-1].value
			if not parameter_types_command and value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
				parameter_types_command = value
			if not return_type_command and value.command == PreprocessorCommandEnum.RETURN_TYPE:
				return_type_command = value
		parameter_types = []
		if parameter_types_command:
			i = 0
			parameter_types_command_arguments_count = len(parameter_types_command.arguments)
			while i < len(parameters):
				if parameters[i] != "...":
					if i < parameter_types_command_arguments_count:
						self.push_to_scope({ScopeObjectEnum.NAME: parameters[i],
							ScopeObjectEnum.IS_PARAMETER: True,
							ScopeObjectEnum.TYPE: parameter_types_command.arguments[i]}, False)
						parameter_types.append(parameter_types_command.arguments[i])
				else:
					break
				i += 1

		return_type = None
		
		if return_type_command:
			return_type = return_type_command.arguments

		new_parameters = []
		i = 0
		parameter_type_count = len(parameter_types)
		while i < len(parameters):
			if i < parameter_type_count:
				new_parameters.append({ScopeObjectEnum.NAME: parameters[i],
					ScopeObjectEnum.TYPE: parameter_types[i]})
			else:
				new_parameters.append({ScopeObjectEnum.NAME: parameters[i]})
			i += 1

		if isinstance(a_name, Identifier):
			if return_type:
				self.push_to_scope({ScopeObjectEnum.NAME: a_name, ScopeObjectEnum.IS_FUNCTION: True,
					ScopeObjectEnum.PARAMETERS: new_parameters,
					ScopeObjectEnum.TYPE: return_type}, False)
			else:
				self.push_to_scope({ScopeObjectEnum.NAME: a_name, ScopeObjectEnum.IS_FUNCTION: True,
					ScopeObjectEnum.PARAMETERS: new_parameters}, False)
		elif (isinstance(a_name, MemberExpression) and a_name.operator_type == TokenEnum.COLON
			and isinstance(a_name.base, Identifier)):
			variable = self.is_variable_in_scope(a_name.base)
			if variable:
				if variable.get(ScopeObjectEnum.TYPE, "undefined") == "table":
					functions = variable.get(ScopeObjectEnum.FUNCTIONS, None)
					table_function = None
					if parameter_types:
						table_function = {ScopeObjectEnum.NAME: a_name,
							ScopeObjectEnum.IS_FUNCTION: True, ScopeObjectEnum.PARAMETERS: new_parameters}
					else:
						table_function = {ScopeObjectEnum.NAME: a_name,
							ScopeObjectEnum.IS_FUNCTION: True, ScopeObjectEnum.PARAMETERS: parameters}
					if return_type:
						table_function[ScopeObjectEnum.TYPE] = return_type
					if functions:
						functions[str(a_name.identifier)] = table_function
					else:
						variable[ScopeObjectEnum.FUNCTIONS] = {str(a_name.identifier): table_function}
		return FunctionSignature(a_name, parameters, a_is_local)

	#@timed
	def parse_while_statement(self):
		condition = self.parse_expected_expression()
		self.expect(TokenEnum.KW_DO)
		return WhileStatement(condition)

	#@timed
	def parse_for_statement(self):
		variable = self.parse_identifier()
		if self.consume(TokenEnum.OP_ASSIGN):
			start = self.parse_expected_expression()
			self.expect(TokenEnum.COMMA)
			end = self.parse_expected_expression()
			step = None
			if self.consume(TokenEnum.COMMA):
				step = self.parse_expected_expression()
			self.expect(TokenEnum.KW_DO)
			self.push_to_scope({ScopeObjectEnum.NAME: variable, ScopeObjectEnum.TYPE: "number",
				ScopeObjectEnum.IS_VARIABLE: True}, True)
			return ForNumericStatement(variable, start, end, step)
		else:
			variables = [variable]
			while self.consume(TokenEnum.COMMA):
				variable = self.parse_identifier()
				variables.append(variable)
			self.expect(TokenEnum.KW_IN)
			iterators = [self.parse_expected_expression()]
			while self.consume(TokenEnum.COMMA):
				iterators.append(self.parse_expected_expression())
			self.expect(TokenEnum.KW_DO)
			i = 0
			while i < len(variables):
				self.push_to_scope({ScopeObjectEnum.NAME: variables[i], ScopeObjectEnum.TYPE: "nil",
					ScopeObjectEnum.IS_VARIABLE: True}, True)
				i += 1
			while self.consume(TokenEnum.PREPROCESSOR_COMMAND):
				value = self.processed_tokens[-1].value
				if value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
					i = 0
					arguments_count = len(value.arguments)
					while i < len(variables):
						if i < arguments_count:
							self.push_to_scope({ScopeObjectEnum.NAME: variables[i],
								ScopeObjectEnum.TYPE: value.arguments[i],
								ScopeObjectEnum.IS_VARIABLE: True}, False)
						i += 1
			return ForGenericStatement(variables, iterators)

	#@timed
	def parse_goto_statement(self):
		name = self.parse_identifier()
		return GotoStatement(name)

	#@timed
	def parse_label_statement(self):
		name = self.parse_identifier()
		self.expect(TokenEnum.DOUBLE_COLON)
		return LabelStatement(name)

	#@timed
	def parse_assignment_or_call_statement(self):
		expression = self.parse_prefix_expression()
		if self.peek(TokenEnum.COMMA, 0) or self.peek(TokenEnum.OP_ASSIGN, 0):
			if not expression:
				self.raise_error(ParsingError, "Expected an expression")
			variables = [expression]
			while self.consume(TokenEnum.COMMA):
				exp = self.parse_prefix_expression()
				if not expression:
					self.raise_error(ParsingError, "Expected an expression")
				variables.append(exp)
			self.expect(TokenEnum.OP_ASSIGN)
			initial_values = [self.parse_expected_expression()]
			while self.consume(TokenEnum.COMMA):
				initial_values.append(self.parse_expected_expression())
			i = 0
			while i < len(variables):
				self.push_to_scope({ScopeObjectEnum.NAME: variables[i],
					ScopeObjectEnum.TYPE: self.node_visitor(initial_values[i]),
					ScopeObjectEnum.IS_VARIABLE: True})
				i += 1
			while self.consume(TokenEnum.PREPROCESSOR_COMMAND):
				value = self.processed_tokens[-1].value
				if value.command == PreprocessorCommandEnum.VARIABLE_TYPES:
					i = 0
					arguments_count = len(value.arguments)
					while i < len(variables):
						if i < arguments_count:
							self.push_to_scope({ScopeObjectEnum.NAME: variables[i],
								ScopeObjectEnum.TYPE: value.arguments[i],
								ScopeObjectEnum.IS_VARIABLE: True}, False)
						i += 1
			return AssignmentStatement(variables, initial_values)
		if not expression:
			self.raise_error(ParsingError, "Expected a call statement")
		return CallStatement(expression)

	#@timed
	def parse_identifier(self, a_in_expression = False):
		if self.peek(TokenEnum.NAME, 0):
			identifier = self.tokens_to_process[0].value
			self.next()
			return Identifier(identifier)
		if a_in_expression:
			return None
		self.raise_error(ParsingError, "Expected a name")

	#@timed
	def parse_expression(self):
		expression = self.parse_sub_expression(0)
		self.node_visitor(expression)
		return expression

	#@timed
	def parse_expected_expression(self):
		expression = self.parse_expression()
		if not expression:
			self.raise_error(ExpectedExpressionError, "Expected an expression")
		else:
			return expression

	#@timed
	def parse_sub_expression(self, a_min_precedence):
		operator_type = self.tokens_to_process[0].type
		expression = None
		if self.is_unary_op(operator_type):
			self.next()
			argument = self.parse_sub_expression(10)
			if not argument:
				self.raise_error(ExpectedExpressionError, "Expected a sub-expression")
			expression = UnaryExpression(operator_type, argument)
		if not expression:
			expression = self.parse_primary_expression()
			if not expression:
				expression = self.parse_prefix_expression()
		if not expression:
			return None

		while True:
			operator_type = self.tokens_to_process[0].type
			precedence = self.binary_precedence(operator_type)
			if precedence == 0 or precedence <= a_min_precedence:
				break
			if operator_type == TokenEnum.OP_POW or operator_type == TokenEnum.OP_CONCAT:
				precedence -= 1
			self.next()
			right = self.parse_sub_expression(precedence)
			if not right:
				self.raise_error(ExpectedExpressionError, "Expected a sub-expression")
			expression = BinaryExpression(operator_type, expression, right)
		return expression

	#@timed
	def is_unary_op(self, a_type):
		return {
			TokenEnum.OP_LEN: True,
			TokenEnum.OP_SUB: True,
			TokenEnum.OP_BIT_NOT_XOR: True,
			TokenEnum.KW_NOT: True
		}.get(a_type, False)

	#@timed
	def binary_precedence(self, a_type):
		return {
			TokenEnum.OP_POW: 12,
			TokenEnum.OP_MUL: 10,
			TokenEnum.OP_MOD: 10,
			TokenEnum.OP_DIV: 10,
			TokenEnum.OP_IDIV: 10,
			TokenEnum.OP_ADD: 9,
			TokenEnum.OP_SUB: 9,
			TokenEnum.OP_CONCAT: 8,
			TokenEnum.OP_BIT_RSHIFT: 7,
			TokenEnum.OP_BIT_LSHIFT: 7,
			TokenEnum.OP_BIT_AND: 6,
			TokenEnum.OP_BIT_NOT_XOR: 5,
			TokenEnum.OP_BIT_OR: 4,
			TokenEnum.OP_GREATER: 3,
			TokenEnum.OP_LESS: 3,
			TokenEnum.OP_GREATER_THAN_OR_EQUAL: 3,
			TokenEnum.OP_LESS_THAN_OR_EQUAL: 3,
			TokenEnum.OP_NOT_EQUAL: 3,
			TokenEnum.OP_EQUAL: 3,
			TokenEnum.KW_AND: 2,
			TokenEnum.KW_OR: 1
		}.get(a_type, 0)

	#@timed
	def parse_prefix_expression(self):
		base = None
		if self.peek(TokenEnum.NAME, 0): # Prefix
			base = self.parse_identifier()
		elif self.consume(TokenEnum.LEFT_PARENTHESIS):
			if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
				base = self.parse_expected_expression()
				self.expect(TokenEnum.RIGHT_PARENTHESIS)
		else:
			return None
		while True: # Suffix
			if self.consume(TokenEnum.LEFT_BRACKET):
				expression = self.parse_expected_expression()
				base = IndexExpression(base, expression)
				self.expect(TokenEnum.RIGHT_BRACKET)
			elif self.consume(TokenEnum.DOT):
				identifier = self.parse_identifier(True)
				if not identifier:
					self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=[base,
							TokenEnum.DOT])
				base = MemberExpression(base, TokenEnum.DOT, identifier)
				self.node_visitor(base)
			elif self.consume(TokenEnum.COLON):
				identifier = self.parse_identifier(True)
				if not identifier:
					self.raise_error(ExpectedNameError, "Expected a name", a_additional_arguments=[base,
							TokenEnum.COLON])
				base = MemberExpression(base, TokenEnum.COLON, identifier)
				base = self.parse_call_expression(base)
				self.node_visitor(base)
			elif self.peek(TokenEnum.LEFT_PARENTHESIS, 0) or self.peek(TokenEnum.LEFT_CURLY_BRACE, 0):
				base = self.parse_call_expression(base)
			elif self.peek(TokenEnum.STRING, 0):
				base = self.parse_call_expression(base)
			else:
				return base
		return base

	#@timed
	def parse_call_expression(self, a_base):
		def expect_parameter_expression(a_expressions):
			nth_parameter = len(a_expressions)
			base_type = None
			if isinstance(a_base, Identifier):
				base_type = self.node_visitor(a_base.value)
			else:
				base_type = self.node_visitor(a_base.base)
			class_ = self.scope[0][APIKeyEnum.CLASSES].get(str(base_type), None)
			if class_:
				functions = class_.get(ScopeObjectEnum.FUNCTIONS, None)
				if functions:
					function = functions.get(str(a_base.identifier), None)
					if function:
						self.raise_error(ExpectedFunctionParameterExpressionError,
							"Expected a parameter expression",
							a_additional_arguments=[function, nth_parameter])
			function = self.is_function_in_scope(str(a_base))
			if function:
				self.raise_error(ExpectedFunctionParameterExpressionError,
					"Expected a parameter expression for a local function",
					a_additional_arguments=[function, nth_parameter])
			function = self.is_namespace_function_in_api(str(a_base))
			if function:
				parameters = function.get(ScopeObjectEnum.PARAMETERS, None)
				if parameters:
					if (parameters[0].get(ScopeObjectEnum.TYPE) == "table"
						and parameters[0].get(ScopeObjectEnum.NAME) == "ref"):
						function = copy.copy(function)
						function[ScopeObjectEnum.PARAMETERS] = parameters[1:]
				self.raise_error(ExpectedFunctionParameterExpressionError,
					"Expected a parameter expression for a namespace function",
					a_additional_arguments=[function, nth_parameter])
			class_ = self.scope[0][APIKeyEnum.CLASSES].get(str(a_base), None)
			if class_:
				functions = class_.get(ScopeObjectEnum.FUNCTIONS, None)
				if functions:
					function = functions.get(str(a_base), None)
					if function:
						self.raise_error(ExpectedFunctionParameterExpressionError,
							"Expected a parameter expression for a class constructor",
							a_additional_arguments=[function, nth_parameter])
			namespace = self.scope[0][APIKeyEnum.NAMESPACES].get(str(base_type), None)
			if namespace:
				functions = namespace.get(ScopeObjectEnum.FUNCTIONS, None)
				if functions:
					function = functions.get(str(a_base.identifier), None)
					if function:
						self.raise_error(ExpectedFunctionParameterExpressionError,
							"Expected a parameter expression for a namespace function",
							a_additional_arguments=[function, nth_parameter])
			if isinstance(a_base, MemberExpression):
				variable = self.is_variable_in_scope(str(a_base.base))
				if variable:
					functions = variable.get(ScopeObjectEnum.FUNCTIONS, None)
					if functions:
						function = functions.get(str(a_base.identifier), None)
						if function:
							self.raise_error(ExpectedFunctionParameterExpressionError,
								"Expected a parameter expression for a local function",
								a_additional_arguments=[function, nth_parameter])
			self.raise_error(ExpectedFunctionParameterExpressionError,
				"Expected a parameter expression for a local function",
				a_additional_arguments=[a_base, nth_parameter])

		if self.consume(TokenEnum.LEFT_PARENTHESIS):
			expressions = []
			if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
				expression = self.parse_expression()
				if expression:
					expressions.append(expression)
				else:
					expect_parameter_expression(expressions)
				while self.consume(TokenEnum.COMMA):
					expression = self.parse_expression()
					if not expression:
						expect_parameter_expression(expressions)
					expressions.append(expression)
				if not self.consume(TokenEnum.RIGHT_PARENTHESIS):
					expect_parameter_expression(expressions)
					self.expect(TokenEnum.RIGHT_PARENTHESIS)
			return CallExpression(a_base, expressions)
		elif self.consume(TokenEnum.LEFT_CURLY_BRACE):
			return TableCallExpression(a_base, self.parse_table_constructor())
		elif self.consume(TokenEnum.STRING):
			return StringCallExpression(a_base, self.parse_primary_expression())
		self.raise_error(ParsingError, "Expected a call expression")

	#@timed
	def parse_primary_expression(self):
		if (self.peek(TokenEnum.STRING, 0) or self.peek(TokenEnum.NUMBER, 0)
			or self.peek(TokenEnum.KW_TRUE, 0) or self.peek(TokenEnum.KW_FALSE, 0)
			or self.peek(TokenEnum.KW_NIL, 0) or self.peek(TokenEnum.VARARG, 0)):
			type_ = self.tokens_to_process[0].type
			value = self.tokens_to_process[0].value
			self.next()
			return Literal(type_, value)
		elif self.consume(TokenEnum.KW_FUNCTION):
			return self.parse_function_declaration(None, False)
		elif self.consume(TokenEnum.LEFT_CURLY_BRACE):
			return self.parse_table_constructor()

	#@timed
	def parse_table_constructor(self):
		fields = []
		while True:
			if self.consume(TokenEnum.LEFT_BRACKET):
				key = self.parse_expected_expression()
				self.expect(TokenEnum.RIGHT_BRACKET)
				self.expect(TokenEnum.OP_ASSIGN)
				value = self.parse_expected_expression()
				field.append(TableKey(key, value))
			elif self.peek(TokenEnum.NAME, 0):
				if self.peek(TokenEnum.OP_ASSIGN, 1):
					key = self.parse_identifier()
					self.next()
					value = self.parse_expected_expression()
					fields.append(TableKeyString(key, value))
				else:
					value = self.parse_expected_expression()
					fields.append(TableValue(value))
			else:
				value = self.parse_expression()
				if not value:
					break
				fields.append(TableValue(value))
			if self.peek(TokenEnum.COMMA, 0) or self.peek(TokenEnum.SEMICOLON, 0):
				self.next()
				continue
			break
		self.expect(TokenEnum.RIGHT_CURLY_BRACE)
		return TableConstructorExpression(fields)

	#@timed
	def is_arithmetic_operator(self, a_operator_type):
		return {
			TokenEnum.OP_ADD : True,
			TokenEnum.OP_DIV : True,
			TokenEnum.OP_IDIV : True,
			TokenEnum.OP_MOD : True,
			TokenEnum.OP_MUL : True,
			TokenEnum.OP_POW : True,
			TokenEnum.OP_SUB : True
		}.get(a_operator_type, False)

	#@timed
	def is_comparison_operator(self, a_operator_type):
		return {
			TokenEnum.OP_EQUAL : True,
			TokenEnum.OP_GREATER : True,
			TokenEnum.OP_GREATER_THAN_OR_EQUAL : True,
			TokenEnum.OP_LESS : True,
			TokenEnum.OP_LESS_THAN_OR_EQUAL : True,
			TokenEnum.OP_NOT_EQUAL : True,
			TokenEnum.KW_AND : True,
			TokenEnum.KW_OR : True
		}.get(a_operator_type, False)

	#@timed
	def is_bitwise_operator(self, a_operator_type):
		return {
			TokenEnum.OP_BIT_AND : True,
			TokenEnum.OP_BIT_OR : True,
			TokenEnum.OP_BIT_NOT_XOR : True,
			TokenEnum.OP_BIT_LSHIFT : True,
			TokenEnum.OP_BIT_RSHIFT : True
		}.get(a_operator_type, False)

	#@timed
	def node_visitor(self, a_node, a_previous = None, a_indent = "\t"):
		result = "undefined"
		calling_function = False
		indent_step = "\t"
#		SharedFunctions.debug_print(a_indent, "Entering", str(a_node), type(a_node), "with", str(a_previous))
		type_ = type(a_node)
		if type_ == BinaryExpression:
			lexp = self.node_visitor(a_node.left_expression, a_indent=a_indent + indent_step)
			rexp = self.node_visitor(a_node.right_expression, a_indent=a_indent + indent_step)
			if self.is_arithmetic_operator(a_node.operator_type):
				result = "number"
			elif self.is_comparison_operator(a_node.operator_type):
				result = "boolean"
			elif self.is_bitwise_operator(a_node.operator_type):
				result = "number"
			elif a_node.operator_type == TokenEnum.OP_CONCAT:
				result = "string"
			else:
				self.raise_error(ParsingError, "Unsupported binary operator %s"
					% TOKEN_DESCRIPTION[a_node.operator_type])
		elif type_ == UnaryExpression:
			exp = self.node_visitor(a_node.expression, a_indent=a_indent + indent_step)
			if a_node.operator_type == TokenEnum.OP_LEN:
				result = "number"
			elif a_node.operator_type == TokenEnum.OP_SUB:
				result = exp
			elif a_node.operator_type == TokenEnum.OP_BIT_NOT_XOR:
				result = "number"
			elif a_node.operator_type == TokenEnum.KW_NOT:
				result = "boolean"
		elif type_ == Literal:
			if a_node.type == TokenEnum.NUMBER:
				result = "number"
			elif a_node.type == TokenEnum.STRING:
				result = "string"
			elif a_node.type == TokenEnum.KW_TRUE:
				result = "true"
			elif a_node.type == TokenEnum.KW_FALSE:
				result = "false"
			elif a_node.type == TokenEnum.KW_NIL:
				result = "nil"
		elif type_ == MemberExpression:
			if a_node.operator_type == TokenEnum.COLON:
				calling_function = True
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.identifier, NodeResult(result.type, calling_function),
				a_indent=a_indent + indent_step)
		elif type_ == IndexExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
		elif type_ == TableConstructorExpression:
			result = "table"
		elif type_ == TableValue:
			result = self.node_visitor(a_node.value, a_indent=a_indent + indent_step)
		elif type_ == TableKeyString:
			result = self.node_visitor(a_node.key, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.value, a_indent=a_indent + indent_step)
		elif type_ == TableKey:
			result = self.node_visitor(a_node.key, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.value, a_indent=a_indent + indent_step)
		elif type_ == StringCallExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.expression, a_indent=a_indent + indent_step)
		elif type_ == TableCallExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			result = self.node_visitor(a_node.table, a_indent=a_indent + indent_step)
		elif type_ == CallExpression:
			result = self.node_visitor(a_node.base, a_indent=a_indent + indent_step)
			if a_node.expressions: # Arguments
				for argument in a_node.expressions:
					self.node_visitor(argument, a_indent=a_indent + indent_step)
		elif type_ == Identifier:
			if not a_previous:
				variable = self.is_variable_in_scope(a_node)
				if variable:
					variable_type = variable.get(ScopeObjectEnum.TYPE, None)
					if variable_type:
						result = variable_type
				else:
					parameter = self.is_parameter_in_scope(a_node)
					if parameter:
						parameter_type = parameter.get(ScopeObjectEnum.TYPE, None)
						if parameter_type:
							result = parameter_type
					else:
						enum = self.is_enum_in_api(a_node)
						if enum:
							result = str(a_node)
						else:
							function = self.is_function_in_api(a_node)
							if function:
								result = function.get(ScopeObjectEnum.TYPE, "nil")
							else:
								namespace = self.is_namespace_in_api(a_node)
								if namespace:
									result = str(a_node)
								else:
									namespace_function = self.is_namespace_function_in_api(a_node)
									if namespace_function:
										result = namespace_function.get(ScopeObjectEnum.TYPE, "nil")
									else:
										self.raise_error(ParsingError, "Could not figure out what '%s' is"
											% a_node)
			else:
				class_ = self.is_class_in_api(a_previous)
				if class_:
					if a_previous.calling_function:
						functions = class_.get(ScopeObjectEnum.FUNCTIONS, None)
						if functions:
							function = functions.get(str(a_node), None)
							if function:
								returns = function.get(ScopeObjectEnum.RETURNS, None)
								if returns:
									result = returns[ScopeObjectEnum.TYPE]
								else:
									result = "nil"
							else:
								self.raise_error(ParsingError,
									"'%s' class does not have a function called '%s'"
									% (a_previous, a_node))
					else:
						attributes = class_.get(ScopeObjectEnum.ATTRIBUTES, None)
						if attributes:
							attribute = attributes.get(str(a_node), None)
							if attribute:
								result = attribute[ScopeObjectEnum.TYPE]
							else:
								functions = class_.get(ScopeObjectEnum.FUNCTIONS, None)
								if functions:
									function = functions.get(str(a_node), None)
									if function:
										returns = function.get(ScopeObjectEnum.RETURNS, None)
										if returns:
											result = returns[ScopeObjectEnum.TYPE]
										else:
											result = "nil"
									else:
										self.raise_error(ParsingError,
											"'%s' class does not have an attribute or a function called '%s'"
											% (a_previous, a_node))
				if not class_:
					namespace = self.is_namespace_in_api(a_previous)
					if namespace:
						functions = namespace.get(ScopeObjectEnum.FUNCTIONS, None)
						if functions:
							function = functions.get(str(a_node), None)
							if function:
								returns = function.get(ScopeObjectEnum.RETURNS, None)
								if returns:
									result = returns[ScopeObjectEnum.TYPE]
								else:
									result = "nil"
							else:
								self.raise_error(ParsingError,
									"'%s' namespace does not have a function called '%s'"
									% (a_previous, a_node))
					if not namespace:
						enum = self.is_enum_in_api(a_previous)
						if enum:
							name = str(a_node)
							found = False
							for member in enum.get(ScopeObjectEnum.MEMBERS, []):
								if member[ScopeObjectEnum.NAME] == name:
									found = True
									result = "number"
									break
							if not found:
								self.raise_error(ParsingError,
									"'%s' enum does not have an enumerator called '%s'"
									% (a_previous, a_node))

		elif type_ == list:
			for expression in a_node:
				self.node_visitor(expression, a_indent=a_indent + indent_step)
#		else:
#			SharedFunctions.debug_print(a_indent, "Unknown node type", type_)
#		SharedFunctions.debug_print(a_indent, "Exiting", str(a_node), type(a_node), "with", str(result))
		return NodeResult(result, calling_function)

def get_variable_completion(a_name, a_type):
	a_type = "%s " % a_type
	return (("%s\t%svar." % (a_name.lower(), a_type)).strip(), a_name,)

def get_parameter_completion(a_name, a_type):
	a_type = "%s " % a_type
	return (("%s\t%sparam." % (a_name.lower(), a_type)).strip(), a_name,)

def get_function_completion(a_name, a_type, a_parameters):
	a_type = "%s " % a_type
	parameters = []
	i = 1
	for param in a_parameters:
		if isinstance(param, dict):
			parameters.append("${%d:%s}" % (i, param.get(ScopeObjectEnum.NAME, "<name>")))
		else:
			parameters.append("${%d:%s}" % (i, param))
		i += 1
	return (("%s\t%sfunc." % (a_name.lower(), a_type)).strip(), "%s(%s)" % (a_name, ", ".join(parameters)),)

def get_function_as_attribute_completion(a_name, a_type):
	a_type = "%s " % a_type
	return (("%s\t%sfunc." % (a_name.lower(), a_type)).strip(), a_name,)

def get_constructor_completion(a_name, a_type, a_parameters):
	a_type = "%s " % a_type
	parameters = []
	i = 1
	for param in a_parameters:
		parameters.append("${%d:%s}" % (i, param))
		i += 1
	return (("%s\t%sconstr." % (a_name.lower(), a_type)).strip(), "%s(%s)" % (a_name, ", ".join(parameters)),)

def get_namespace_completion(a_name):
	return ("%s\tnamespace" % a_name.lower(), a_name,)

def get_enum_completion(a_name):
	return ("%s\tenum" % a_name.lower(), a_name,)

def get_attribute_completion(a_name, a_type):
	a_type = "%s " % a_type
	return (("%s\t%sattr." % (a_name.lower(), a_type)).strip(), a_name,)

def get_all_namespace_completions(a_scope_list, a_functions_only):
	result = []
	for name, namespace in a_scope_list[0].get(APIKeyEnum.NAMESPACES, {}).items():
		if not a_functions_only:
			result.append(get_namespace_completion(name))
		for function_key, function in namespace.get(ScopeObjectEnum.FUNCTIONS, {}).items():
			returns = function.get(APIKeyEnum.RETURNS, "")
			if returns:
				returns = returns[APIKeyEnum.TYPE]

			parameters = function.get(APIKeyEnum.PARAMETERS, [])
			if parameters:
				if (parameters[0].get(APIKeyEnum.TYPE, "") == "table"
					and parameters[0].get(APIKeyEnum.NAME, "") == "ref"):
					parameters = [param.get(APIKeyEnum.NAME, "<arg>")
						for param in parameters[1:]]
				else:
					parameters = [param.get(APIKeyEnum.NAME, "<arg>")
						for param in parameters]
			result.append(get_function_completion(function_key, returns, parameters))
	return result

def get_all_base_script_completions(a_scope_list):
	result = []
	if not a_scope_list:
		return result
	variables = {}
	parameters = {}
	functions = {}
	for scope in reversed(a_scope_list[1:]):
		for name, scope_object in scope.items():
			if scope_object.get(ScopeObjectEnum.IS_VARIABLE, False):
				if not variables.get(name, None):
					variables[name] = scope_object
			elif scope_object.get(ScopeObjectEnum.IS_PARAMETER, False):
				if not parameters.get(name, None):
					parameters[name] = scope_object
			elif scope_object.get(ScopeObjectEnum.IS_FUNCTION, False):
				if not functions.get(name, None):
					functions[name] = scope_object

	for name, variable in variables.items():
		result.append(get_variable_completion(name,
			variable.get(ScopeObjectEnum.TYPE, "")))
	for name, parameter in parameters.items():
		result.append(get_parameter_completion(name,
			parameter.get(ScopeObjectEnum.TYPE, "")))
	for name, function in functions.items():
		result.append(get_function_completion(name,
			function.get(ScopeObjectEnum.TYPE, ""),
			[param[ScopeObjectEnum.NAME] if isinstance(param, dict) else str(param) for param
				in function.get(ScopeObjectEnum.PARAMETERS, [])]))

	for name, function in a_scope_list[0].get(APIKeyEnum.FUNCTIONS, {}).items():
		if function.get(ScopeObjectEnum.IS_CONSTRUCTOR, False):
			result.append(get_constructor_completion(name,
				function.get(ScopeObjectEnum.TYPE, ""),
				[param[APIKeyEnum.TYPE] for param in function.get(ScopeObjectEnum.PARAMETERS, [])]))
		else:
			result.append(get_function_completion(name,
				function.get(ScopeObjectEnum.TYPE, ""),
				[param[APIKeyEnum.NAME] for param in function.get(ScopeObjectEnum.PARAMETERS, [])]))


	result.extend(get_all_namespace_completions(a_scope_list, False))

	for name, enum in a_scope_list[0].get(APIKeyEnum.ENUMS, {}).items():
		result.append(get_enum_completion(name))
	return result

def get_all_type_completions(a_scope_list):
	result = []
	for class_key in a_scope_list[0].get(APIKeyEnum.CLASSES, []):
		result.append(("%s\tclass" % (class_key.lower()), class_key,))
	for enum_key in a_scope_list[0].get(APIKeyEnum.ENUMS, []):
		result.append(("%s\tenum" % (enum_key.lower()), enum_key,))
	result.append(("%s\ttype" % ("boolean".lower()), "boolean",))
	result.append(("%s\ttype" % ("number".lower()), "number",))
	result.append(("%s\ttype" % ("string".lower()), "string",))
	result.append(("%s\ttype" % ("table".lower()), "table",))
	result.append(("%s\ttype" % ("nil".lower()), "nil",))
	result.append(("%s\ttype" % ("float".lower()), "float",))
	result.append(("%s\ttype" % ("integer".lower()), "integer",))
	return result

def clear_linter_highlights(a_view):
	a_view.erase_regions("subliming_of_isaac_linter_errors")

def add_linter_highlight(a_view, a_line, a_column = None):
	regions = a_view.get_regions("subliming_of_isaac_linter_errors")
	if a_column: # Highlight a word
		point = a_view.text_point(a_line-1, a_column)
		regions.append(a_view.word(sublime.Region(point)))
	else: # Highlight a line
		point = a_view.text_point(a_line-1, 1)
		regions.append(a_view.line(sublime.Region(point)))
	if len(regions) > 0:
		a_view.add_regions("subliming_of_isaac_linter_errors", regions, "invalid")

class EventListener(sublime_plugin.EventListener):
	__slots__ = [
		"parser",
		"parsing",
		"queue",
		"view",
		"statement_cache",
		"capable_of_popup"
	]
	def __init__(self):
		self.parser = Parser()
		self.parsing = False
		self.queue = 0
		self.statement_cache = {}
		self.capable_of_popup = None

	def scrape_api(self, a_index):
		if a_index >= 0:
			sublime.active_window().run_command("subliming_of_isaac_scrape_docs")

	def add_completions_flags(self, a_completions):
		return (a_completions, sublime.INHIBIT_WORD_COMPLETIONS | sublime.INHIBIT_EXPLICIT_COMPLETIONS,)

	def on_query_completions(self, a_view, a_prefix, a_locations):
		settings = SharedFunctions.get_package_settings()
		if (a_view.scope_name(0).split(" ")[0] in settings.get("completions_scope")
			and settings.get("context_completions", True) and settings.get("enable_linter", True)):
			if self.parsing:
				return
			elif not self.parser.afterbirth_api:
				sublime.status_message("Linter needs to complete successfully before completions can be given")
				return
			self.parsing = True
			start_time = time.time()

			def exit():
#				SharedFunctions.debug_print("Finished completing in %f milliseconds."
#					% ((time.time() - start_time)*1000))
				self.parsing = False

			completions = []
			identifier = self.view.buffer_id()
			caret_point = a_view.sel()[0].begin()
			caret_line, caret_column = a_view.rowcol(caret_point)
			script_to_cursor = a_view.substr(sublime.Region(a_view.line(caret_point).begin(), caret_point))
			if len(a_prefix) > 0:
				script_to_cursor = script_to_cursor[:-len(a_prefix)]
			last_char = None
			if len(script_to_cursor) > 0:
				last_char = script_to_cursor[-1]
			self.invalidate_statement_cache(caret_line, identifier)
			scopes = self.get_scope(caret_line, identifier)
			try: # Successful parsing
				line = [a for a in self.parser.parse(script_to_cursor, caret_line, scopes, True)]
				if not line:
					if not scopes:
						scopes = self.parser.get_initial_scope()
					# Functions, namespaces, variables, parameters
					completions = get_all_base_script_completions(scopes)
			except LexingError as error:
				if PYTHON_VERSION[0] >= 3:
					sublime.status_message("Lexing error on line %d, column %d: %s" % (error.line, error.column,
						error.message))
			except ExpectedNameError as error:
				try:
					classes = self.parser.afterbirth_api.get(APIKeyEnum.CLASSES, None)
					enums = self.parser.afterbirth_api.get(APIKeyEnum.ENUMS, None)
					functions = self.parser.afterbirth_api.get(APIKeyEnum.FUNCTIONS, None)
					namespaces = self.parser.afterbirth_api.get(APIKeyEnum.NAMESPACES, None)
					if not classes or not enums or not functions or not namespaces:
						SharedFunctions.debug_print("ERROR: Afterbirth+ API is missing one or more major"
							+ " parts of it (classes, enums, functions, and/or namespaces)")
						return exit() # Use static completions as a fallback tactic when the API is not working
					expression_result = self.parser.node_visitor(error.base)
					if error.preceding_operator_type == TokenEnum.DOT:
						if str(expression_result) == "table":
							variable = self.parser.is_variable_in_scope(error.base)
							if variable and variable.get(ScopeObjectEnum.TYPE, "undefined") == "table":
								functions = variable.get(ScopeObjectEnum.FUNCTIONS, None)
								if functions:
									for function_key, function in functions.items():
										returns = function.get(ScopeObjectEnum.TYPE, "")
										completions.append(get_function_as_attribute_completion(function_key,
											returns))
						else:
							class_ = classes.get(str(expression_result), None)
							if class_:
								for attribute_key, attribute in class_.get(APIKeyEnum.ATTRIBUTES, {}).items():
									completions.append(get_attribute_completion(attribute_key,
										attribute[APIKeyEnum.TYPE]))
								for function_key, function in class_.get(APIKeyEnum.FUNCTIONS, {}).items():
									returns = function.get(APIKeyEnum.RETURNS, "")
									if returns:
										returns = returns[APIKeyEnum.TYPE]
									completions.append(get_function_as_attribute_completion(function_key,
										returns))
							else:
								enum = enums.get(str(expression_result), None)
								if enum:
									for enumerator in enum.get(APIKeyEnum.MEMBERS, []):
										contents = enumerator[APIKeyEnum.NAME]
										name = contents.lower()
										completions.append(("%s\tenumerator"
											% (name), contents,))
								else:
									namespace = namespaces.get(str(expression_result), None)
									if namespace:
										for function_key, function in namespace.get(APIKeyEnum.FUNCTIONS,
											{}).items():
											parameters = function.get(APIKeyEnum.PARAMETERS, [])
											if parameters:
												if (parameters[0].get(APIKeyEnum.TYPE, "") == "table"
													and parameters[0].get(APIKeyEnum.NAME, "") == "ref"):
													continue
											returns = function.get(APIKeyEnum.RETURNS, "")
											if returns:
												returns = returns[APIKeyEnum.TYPE]
											parameters = [param.get(APIKeyEnum.NAME, "<arg>") for param
												in function.get(APIKeyEnum.PARAMETERS, [])]
											completions.append(get_function_completion(function_key,
												returns, parameters))
					elif error.preceding_operator_type == TokenEnum.COLON:
						if str(expression_result) == "table":
							variable = self.parser.is_variable_in_scope(error.base)
							if variable and variable.get(ScopeObjectEnum.TYPE, "undefined") == "table":
								functions = variable.get(ScopeObjectEnum.FUNCTIONS, None)
								if functions:
									for function_key, function in functions.items():
										parameters = function.get(ScopeObjectEnum.PARAMETERS, [])
										returns = function.get(ScopeObjectEnum.TYPE, "")
										completions.append(get_function_completion(function_key,
											returns, parameters))
							if not scopes:
								scopes = self.parser.get_initial_scope()
							completions.extend(get_all_namespace_completions(scopes, True))
						else:
							class_ = classes.get(str(expression_result), None)
							if class_:
								for function_key, function in class_.get(APIKeyEnum.FUNCTIONS, {}).items():
									parameters = function.get(APIKeyEnum.PARAMETERS, [])
									if parameters:
										if (parameters[0].get(APIKeyEnum.TYPE, "") == "table"
											and parameters[0].get(APIKeyEnum.NAME, "") == "ref"):
											parameters = parameters[1:]
											continue
									parameters = [param.get(APIKeyEnum.NAME, "<arg>") for param
										in function.get(APIKeyEnum.PARAMETERS, [])]
									returns = function.get(APIKeyEnum.RETURNS, "")
									if returns:
										returns = returns[APIKeyEnum.TYPE]
									completions.append(get_function_completion(function_key,
										returns, parameters))
					if not completions:
						if not scopes:
							scopes = self.parser.get_initial_scope()
						completions = get_all_base_script_completions(scopes)
				except ParsingError:
					if not scopes:
						scopes = self.parser.get_initial_scope()
					completions = get_all_base_script_completions(scopes)
			except ExpectedPreprocessorTypeArgumentError as error:
				if not scopes:
					scopes = self.parser.get_initial_scope()
				completions = get_all_type_completions(self.parser.scope)
			except ExpectedFunctionParameterExpressionError as error:
				if not scopes:
					scopes = self.parser.get_initial_scope()
				completions = get_all_base_script_completions(scopes)
				if self.capable_of_popup:
					# Show popup here
					if error.function:
						function_parameters = None
						function_docstring = ""
						if isinstance(error.function, dict):
							parameters = error.function.get(ScopeObjectEnum.PARAMETERS, None)
							if parameters:
								function_parameters = []
								i = 0
								for parameter in parameters:
									parameter_type = ""
									parameter_name = ""
									if isinstance(parameter, dict):
										parameter_type = str(parameter.get(ScopeObjectEnum.TYPE, ""))
										parameter_name = str(parameter.get(ScopeObjectEnum.NAME,
											"<parameter name>"))
										
									else:
										parameter_name = str(parameter)
									if i == error.nth_parameter:
										function_parameters.append(("<b>%s %s</b>"
											% (parameter_type, parameter_name)).strip())
									else:
										function_parameters.append(("%s %s"
											% (parameter_type, parameter_name)).strip())
									i += 1
							if (error.function.get(ScopeObjectEnum.IS_CONSTRUCTOR, False)
								and error.function.get(ScopeObjectEnum.RETURNS, None)):
								function_docstring = ("%s class constructor"
									% error.function[ScopeObjectEnum.RETURNS][ScopeObjectEnum.TYPE])
						if function_parameters:
							css = """<style>
html {
	background-color: #393939;
}
body {
    font-size: 12px;
    color: #747369;
}
b {
    color: #ffffff;
}
h1 {
    color: #bfbfbf;
    font-size: 14px;
}
</style>"""
							if function_docstring:
								function_docstring = "<br><br>%s" % function_docstring
							content = "%sParameters:<br> %s%s" % (css, "<br> ".join(function_parameters),
								function_docstring)
							if a_view.is_popup_visible():
								a_view.update_popup(content)
							else:
								a_view.show_popup(content,
									flags=sublime.COOPERATE_WITH_AUTO_COMPLETE,
									max_width=600,
									max_height=300)
			except ExpectedExpressionError as error:
				if not scopes:
					scopes = self.parser.get_initial_scope()
				completions = get_all_base_script_completions(scopes)
			except ParsingError as error:
				if PYTHON_VERSION[0] >= 3:
					sublime.status_message("Parsing error when completing: %s" % error.message)
			exit()
			return self.add_completions_flags(completions)

	def on_modified(self, a_view):
		settings = SharedFunctions.get_package_settings()
		if (a_view.scope_name(0).split(" ")[0] in settings.get("completions_scope")
			and settings.get("enable_linter", True)):
			clear_linter_highlights(a_view)
			self.view = a_view
			self.identifier = a_view.buffer_id()
			self.source_string = a_view.substr(sublime.Region(0, a_view.size()))
			self.queue += 1
			delay = settings.get("linter_delay", 0.5)
			if delay < 0.25:
				delay = 0.25
			thread = threading.Timer(delay, self.lint)
			thread.daemon = True
			thread.start()

	def on_post_save(self, a_view):
		settings = SharedFunctions.get_package_settings()
		if (a_view.scope_name(0).split(" ")[0] in settings.get("completions_scope")
			and settings.get("enable_linter", True)):
			clear_linter_highlights(a_view)
			self.view = a_view
			self.identifier = a_view.buffer_id()
			self.source_string = a_view.substr(sublime.Region(0, a_view.size()))
			self.queue += 1
			self.lint(True)

	def invalidate_statement_cache(self, a_line_index, a_identifier):
		cache = self.statement_cache.get(a_identifier, None)
		if not cache:
			self.statement_cache[a_identifier] = []
			return
		if a_line_index <= 0: # Invalidation of the entire cache
			self.statement_cache[a_identifier] = []
			return
		else: # Partial invalidation of the cache
			a_line_index += 1 # Linter uses 1-based line numbers, view.rowcol() returns 0-based line numbers
			i = -1
			for line in cache:
				i += 1
				if line[0] >= a_line_index:
					self.statement_cache[a_identifier] = cache[:i]
					break
		return

	def get_scope(self, a_line, a_identifier):
		cache = self.statement_cache.get(a_identifier, None)
		if not cache:
			return None
		return cache[-1][2]

	def push_statement_cache(self, a_lines, a_identifier):
		if not a_lines:
			return
		self.statement_cache[a_identifier].extend(a_lines)

	def get_source_to_lint(self, a_line_index, a_identifier):
		starting_line_index = a_line_index
		if self.statement_cache[a_identifier]:
			starting_line_index = self.statement_cache[a_identifier][-1][0]
		else:
			starting_line_index = 0
		start_point = self.view.text_point(starting_line_index, 0)
		return self.view.substr(sublime.Region(start_point, self.view.size())), starting_line_index

	def lint(self, a_on_save = False):
		self.queue -= 1
		if self.queue > 0:
			return
		if self.parsing:
			return
		if self.capable_of_popup == None:
			self.capable_of_popup = int(sublime.version()) >= 3080
		if int(sublime.version()) >= 3103 and self.view.is_auto_complete_visible():
			return
		self.parsing = True
		start_time = time.time()

		def exit():
			self.parsing = False

		#self.invalidate_statement_cache(0, self.identifier)
		#scope = self.get_scope(0, self.identifier)
		lines = []
		try:
			for line in self.parser.parse(self.source_string, 0, None):#scope):
				if line:
					lines.append(line)
		except LexingError as error:
			if PYTHON_VERSION[0] >= 3 or a_on_save:
				sublime.status_message("Lexing error on line %d, column %d: %s" % (error.line, error.column,
					error.message))
				settings = SharedFunctions.get_package_settings()
				if settings.get("highlight_linter_errors", True):
					add_linter_highlight(self.view, error.line, error.column)
				if a_on_save and settings.get("show_linter_errors_on_save", True):
					error_list = [error.message, "Line %d, column %d" % (error.line, error.column)]
					self.view.window().show_quick_panel([error_list], self.error_choice)
			return exit()
		except ParsingError as error:
			if PYTHON_VERSION[0] >= 3 or a_on_save:
				sublime.status_message("Parsing error on line %d, column %d: %s"
					% (error.line, error.column, error.message))
				settings = SharedFunctions.get_package_settings()
				if settings.get("highlight_linter_errors", True):
					add_linter_highlight(self.view, error.line)
				if a_on_save and settings.get("show_linter_errors_on_save", True):
					error_list = [error.message, "Line %d, column %d" % (error.line, error.column)]
					self.view.window().show_quick_panel([error_list], self.error_choice)
			return exit()
		self.invalidate_statement_cache(0, self.identifier)
		if lines:
			self.push_statement_cache(lines, self.identifier)
		if PYTHON_VERSION[0] >= 3 or a_on_save:
			sublime.status_message("Finished linting in %.0f ms" % ((time.time() - start_time)*1000))
			clear_linter_highlights(self.view)
		self.parsing = False

	def error_choice(self, a_index):
		pass